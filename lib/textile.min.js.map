{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///textile.min.js","webpack:///webpack/bootstrap d3a0f4bd1c1a6085132c","webpack:///./src/index.js","webpack:///./src/merge.js","webpack:///./src/jsonml.js","webpack:///./src/html.js","webpack:///./src/re.js","webpack:///./src/ribbon.js","webpack:///./src/textile/flow.js","webpack:///./src/builder.js","webpack:///./src/fixlinks.js","webpack:///./src/textile/phrase.js","webpack:///./src/textile/attr.js","webpack:///./src/textile/glyph.js","webpack:///./src/textile/re_ext.js","webpack:///./src/textile/list.js","webpack:///./src/textile/deflist.js","webpack:///./src/textile/table.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","textile","txt","opt","merge","defaults","parseFlow","lineOffset","map","toHTML","join","_require","_require2","_require3","parseHtml","breaks","showOriginalLineNumber","cssClassOriginalLineNumber","setOptions","setoptions","parse","convert","html_parser","jsonml","concat","serialize","a","b","k","reIndent","ml","shiftBy","s","test","slice","i","Array","isArray","escape","text","escapeQuotes","replace","tag","shift","attributes","tagAttrs","content","length","_typeof","push","String","singletons","indexOf","Symbol","iterator","obj","constructor","prototype","allowAll","testComment","src","reComment","exec","testOpenTagBlock","reHtmlTagBlock","testOpenTag","reTag","testCloseTag","reEndTag","parseHtmlAttr","attrSrc","attr","reAttr","tokenize","whitelistTags","lazy","tokens","textMode","oktag","oktag_","nesting","nestCount","ribbon","type","COMMENT","data","pos","index","advance","token","CLOSE","isNaN","SINGLE","OPEN","TEXT","valueOf","stack","curr","WS","elm","head","splice","sourceLength","re","pattern","html_id","html_attr","compile","area","base","br","col","embed","hr","img","input","link","meta","option","param","wbr","_cache","punct","space","collapse","expandPatterns","ex","Error","isRegExp","r","Object","toString","flags","arguments","global","ignoreCase","multiline","source","ckey","rx","RegExp","feed","org","slot","self","save","getSlot","getPos","load","n","skipWS","ws","lookbehind","nchars","startsWith","substring","extend","target","_len","args","_key","nextKey","hasOwn","paragraph","pba","linebreak","options","out","split","forEach","bit","trim","parsePhrase","computeCharOffset","removedSrc","match","reCleanBegin","storeCharPosToLine","charOffset","charPosToLine","realSrc","list","builder","linkRefs","charLineOffset","reLinkRef","reBlock","blockType","parseAttr","addLineNumber","extended","reBlockGlob","reBlockExtended","reBlockNormal","reBlockExtendedPre","reBlockNormalPre","inner","cite","par","copyAttr","add","subPba","reFootnoteDef","fnid","class","href","allowedBlocktags","t","pre","code","x","pop","innerHTML","isBlock","innerElm","reRuler","testList","parseList","testDefList","parseDefList","testTable","parseTable","fixLinks","get","_require4","_require5","_require6","_require7","txblocks","txlisthd","txattr","ul","ol","li","div","object","script","noscript","blockquote","notextile","hasOwnProperty","initArr","arr","node","filter","undefined","l","dict","behind","boundary","rePhrase","tok","fence","phraseType","phraseConvert","mMid","mEnd","t1","charAt","reImage","reImageFenced","alt","title","single","element","reFootnote","reCaps","caps","reLink","reLinkFenced","reLinkTitle","parseGlyph","ucaps","txcite","*","**","??","_","__","-","%","+","~","^","@","blacklist","d","testBlock","name","endToken","st","o","style","remaining","isImg","isList","isPhrase","reAlign","reAlignImg","reAlignBlock","reStyles","reCSS","reLang","rm","reClassid","bits","rePaddingL","rePaddingR","align","pbaAlignLookup","reVAlign","reColSpan","reRowSpan","pbaVAlignLookup","v","jsonmlEntryAttr","charPos","<","=",">","<>","reApostrophe","reArrow","reClosingDQuote","reClosingSQuote","reCopyright","reDimsign","reDoublePrime","reEllipsis","reEmdash","reEndash","reOpenDQuote","reOpenSQuote","reRegistered","reSinglePrime","reTrademark","attr_class","attr_style","attr_lang","attr_align","attr_pad","listPad","reList","currIndex","lastIndex","_lst","itemIndex","listAttr","reItem","item","destLevel","substr","newLi","lst","isFinite","parseInt","att","start","apply","reDeflist","deflist","terms","def","localCharOffset","separators","term","parseColgroup","colgroup","isCol","span","width","reTable","rowgroups","caption","tAttr","tCurr","row","more","setRowGroup","reHead","summary","reCaption","reColgroup","reRowgroup","charToTag","reRow","th","cell","mx","table","tbody"],"mappings":"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","file":"textile.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"textile\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"textile\"] = factory();\n\telse\n\t\troot[\"textile\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"textile\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"textile\"] = factory();\n\telse\n\t\troot[\"textile\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t** Textile parser for JavaScript\n\t**\n\t** Copyright (c) 2012 Borgar Þorsteinsson (MIT License).\n\t**\n\t*/\n\t\n\tvar merge = __webpack_require__(1);\n\t\n\tvar _require = __webpack_require__(2),\n\t    toHTML = _require.toHTML;\n\t\n\tvar _require2 = __webpack_require__(6),\n\t    parseFlow = _require2.parseFlow;\n\t\n\tvar _require3 = __webpack_require__(3),\n\t    parseHtml = _require3.parseHtml;\n\t\n\tfunction textile(txt, opt) {\n\t  // get a throw-away copy of options\n\t  opt = merge(merge({}, textile.defaults), opt || {});\n\t  // run the converter\n\t  return parseFlow(txt, opt, opt.lineOffset).map(toHTML).join('');\n\t};\n\tmodule.exports = textile;\n\t\n\t// options\n\ttextile.defaults = {\n\t  // single-line linebreaks are converted to <br> by default\n\t  'breaks': true,\n\t  // by default, don't map the elements of HTML output, with the line numbers of input text\n\t  'showOriginalLineNumber': false,\n\t  // line number offset of the first char of input text, for showOriginalLineNumber option\n\t  'lineOffset': 0,\n\t  // by default, don't set a special CSS class name to each HTML element mapped to an original line number\n\t  'cssClassOriginalLineNumber': ''\n\t};\n\ttextile.setOptions = textile.setoptions = function (opt) {\n\t  merge(textile.defaults, opt);\n\t  return this;\n\t};\n\t\n\ttextile.parse = textile.convert = textile;\n\ttextile.html_parser = parseHtml;\n\t\n\ttextile.jsonml = function (txt, opt) {\n\t  // get a throw-away copy of options\n\t  opt = merge(merge({}, textile.defaults), opt || {});\n\t  // parse and return tree\n\t  return ['html'].concat(parseFlow(txt, opt, opt.lineOffset));\n\t};\n\ttextile.serialize = toHTML;\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports) {\n\n\t\"use strict\";\n\t\n\t// merge object b properties into object a\n\tmodule.exports = function merge(a, b) {\n\t  if (b) {\n\t    for (var k in b) {\n\t      a[k] = b[k];\n\t    }\n\t  }\n\t  return a;\n\t};\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t/*\n\t** JSONML helper methods - http://www.jsonml.org/\n\t**\n\t** This provides the `JSONML` object, which contains helper\n\t** methods for rendering JSONML to HTML.\n\t**\n\t** Note that the tag ! is taken to mean comment, this is however\n\t** not specified in the JSONML spec.\n\t*/\n\t\n\tvar singletons = __webpack_require__(3).singletons;\n\t\n\t// drop or add tab levels to JsonML tree\n\tfunction reIndent(ml, shiftBy) {\n\t  // a bit obsessive, but there we are...\n\t  if (!shiftBy) {\n\t    return ml;\n\t  }\n\t  return ml.map(function (s) {\n\t    if (/^\\n\\t+/.test(s)) {\n\t      if (shiftBy < 0) {\n\t        s = s.slice(0, shiftBy);\n\t      } else {\n\t        for (var i = 0; i < shiftBy; i++) {\n\t          s += '\\t';\n\t        }\n\t      }\n\t    } else if (Array.isArray(s)) {\n\t      return reIndent(s, shiftBy);\n\t    }\n\t    return s;\n\t  });\n\t}\n\t\n\tfunction escape(text, escapeQuotes) {\n\t  return text.replace(/&(?!(#\\d{2,}|#x[\\da-fA-F]{2,}|[a-zA-Z][a-zA-Z1-4]{1,6});)/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/\"/g, escapeQuotes ? '&quot;' : '\"').replace(/'/g, escapeQuotes ? '&#39;' : \"'\");\n\t}\n\t\n\tfunction toHTML(jsonml) {\n\t  jsonml = jsonml.concat();\n\t\n\t  // basic case\n\t  if (typeof jsonml === 'string') {\n\t    return escape(jsonml);\n\t  }\n\t\n\t  var tag = jsonml.shift();\n\t  var attributes = {};\n\t  var tagAttrs = '';\n\t  var content = [];\n\t\n\t  if (jsonml.length && _typeof(jsonml[0]) === 'object' && !Array.isArray(jsonml[0])) {\n\t    attributes = jsonml.shift();\n\t  }\n\t\n\t  while (jsonml.length) {\n\t    content.push(toHTML(jsonml.shift()));\n\t  }\n\t\n\t  for (var a in attributes) {\n\t    tagAttrs += attributes[a] == null ? ' ' + a : ' ' + a + '=\"' + escape(String(attributes[a]), true) + '\"';\n\t  }\n\t\n\t  // be careful about adding whitespace here for inline elements\n\t  if (tag === '!') {\n\t    return '<!--' + content.join('') + '-->';\n\t  } else if (tag in singletons || tag.indexOf(':') > -1 && !content.length) {\n\t    return '<' + tag + tagAttrs + ' />';\n\t  } else {\n\t    return '<' + tag + tagAttrs + '>' + content.join('') + '</' + tag + '>';\n\t  }\n\t}\n\t\n\tmodule.exports = {\n\t  reIndent: reIndent,\n\t  toHTML: toHTML,\n\t  escape: escape\n\t};\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tvar re = __webpack_require__(4);\n\tvar ribbon = __webpack_require__(5);\n\t\n\tre.pattern.html_id = '[a-zA-Z][a-zA-Z\\\\d:]*';\n\tre.pattern.html_attr = '(?:\"[^\"]+\"|\\'[^\\']+\\'|[^>\\\\s]+)';\n\t\n\tvar reAttr = re.compile(/^\\s*([^=\\s]+)(?:\\s*=\\s*(\"[^\"]+\"|'[^']+'|[^>\\s]+))?/);\n\tvar reComment = re.compile(/^<!--(.+?)-->/, 's');\n\tvar reEndTag = re.compile(/^<\\/([:html_id:])([^>]*)>/);\n\tvar reTag = re.compile(/^<([:html_id:])((?:\\s[^=\\s\\/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>/);\n\tvar reHtmlTagBlock = re.compile(/^\\s*<([:html_id:](?::[a-zA-Z\\d]+)*)((?:\\s[^=\\s\\/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>/);\n\t\n\tvar singletons = {\n\t  area: 1,\n\t  base: 1,\n\t  br: 1,\n\t  col: 1,\n\t  embed: 1,\n\t  hr: 1,\n\t  img: 1,\n\t  input: 1,\n\t  link: 1,\n\t  meta: 1,\n\t  option: 1,\n\t  param: 1,\n\t  wbr: 1\n\t};\n\t\n\tfunction allowAll() {\n\t  return true;\n\t}\n\t\n\tfunction testComment(src) {\n\t  return reComment.exec(src);\n\t}\n\t\n\tfunction testOpenTagBlock(src) {\n\t  return reHtmlTagBlock.exec(src);\n\t}\n\t\n\tfunction testOpenTag(src) {\n\t  return reTag.exec(src);\n\t}\n\t\n\tfunction testCloseTag(src) {\n\t  return reEndTag.exec(src);\n\t}\n\t\n\tfunction parseHtmlAttr(attrSrc) {\n\t  // parse ATTR and add to element\n\t  var attr = {};\n\t  var m = void 0;\n\t  while (m = reAttr.exec(attrSrc)) {\n\t    attr[m[1]] = typeof m[2] === 'string' ? m[2].replace(/^([\"'])(.*)\\1$/, '$2') : null;\n\t    attrSrc = attrSrc.slice(m[0].length);\n\t  }\n\t  return attr;\n\t}\n\t\n\tvar OPEN = 'OPEN';\n\tvar CLOSE = 'CLOSE';\n\tvar SINGLE = 'SINGLE';\n\tvar TEXT = 'TEXT';\n\tvar COMMENT = 'COMMENT';\n\tvar WS = 'WS';\n\t\n\tfunction tokenize(src, whitelistTags, lazy) {\n\t  var tokens = [];\n\t  var textMode = false;\n\t  var oktag = whitelistTags ? function (tag) {\n\t    return tag in whitelistTags;\n\t  } : allowAll;\n\t  var oktag_ = oktag;\n\t  var nesting = {};\n\t  var nestCount = 0;\n\t  var m = void 0;\n\t\n\t  src = ribbon(String(src));\n\t\n\t  do {\n\t    // comment\n\t    if ((m = testComment(src)) && oktag('!')) {\n\t      tokens.push({\n\t        type: COMMENT,\n\t        data: m[1],\n\t        pos: src.index(),\n\t        src: m[0]\n\t      });\n\t      src.advance(m[0]);\n\t    }\n\t\n\t    // end tag\n\t    else if ((m = testCloseTag(src)) && oktag(m[1])) {\n\t        var token = {\n\t          type: CLOSE,\n\t          tag: m[1],\n\t          pos: src.index(),\n\t          src: m[0]\n\t        };\n\t        src.advance(m[0]);\n\t        tokens.push(token);\n\t        nesting[token.tag]--;\n\t        nestCount--;\n\t        // console.log( '/' + token.tag, nestCount, nesting );\n\t        if (lazy && (!nestCount || !nesting[token.tag] < 0 || isNaN(nesting[token.tag]))) {\n\t          return tokens;\n\t        }\n\t        // if parse is in text mode then that ends here\n\t        if (textMode) {\n\t          textMode = null;\n\t          oktag = oktag_;\n\t        }\n\t      }\n\t\n\t      // open/void tag\n\t      else if ((m = testOpenTag(src)) && oktag(m[1])) {\n\t          var _token = {\n\t            type: m[3] || m[1] in singletons ? SINGLE : OPEN,\n\t            tag: m[1],\n\t            pos: src.index(),\n\t            src: m[0]\n\t          };\n\t          if (m[2]) {\n\t            _token.attr = parseHtmlAttr(m[2]);\n\t          }\n\t          // some elements can move parser into \"text\" mode\n\t          if (m[1] === 'script' || m[1] === 'code' || m[1] === 'style') {\n\t            textMode = _token.tag;\n\t            oktag = function oktag(tag) {\n\t              return tag === textMode;\n\t            };\n\t          }\n\t          if (_token.type === OPEN) {\n\t            nestCount++;\n\t            nesting[_token.tag] = (nesting[_token.tag] || 0) + 1;\n\t            // console.log( token.tag, nestCount, nesting );\n\t          }\n\t          tokens.push(_token);\n\t          src.advance(m[0]);\n\t        }\n\t\n\t        // text content\n\t        else {\n\t            // no match, move by all \"uninteresting\" chars\n\t            m = /([^<]+|[^\\0])/.exec(src);\n\t            if (m) {\n\t              tokens.push({\n\t                type: TEXT,\n\t                data: m[0],\n\t                pos: src.index(),\n\t                src: m[0]\n\t              });\n\t            }\n\t            src.advance(m ? m[0].length || 1 : 1);\n\t          }\n\t  } while (src.valueOf());\n\t\n\t  return tokens;\n\t}\n\t\n\t// This \"indesciminately\" parses HTML text into a list of JSON-ML element\n\t// No steps are taken however to prevent things like <table><p><td> - user can still create nonsensical but \"well-formed\" markup\n\tfunction parse(tokens, lazy) {\n\t  var root = [];\n\t  var stack = [];\n\t  var curr = root;\n\t  var token = void 0;\n\t  for (var i = 0; i < tokens.length; i++) {\n\t    token = tokens[i];\n\t    if (token.type === COMMENT) {\n\t      curr.push(['!', token.data]);\n\t    } else if (token.type === TEXT || token.type === WS) {\n\t      curr.push(token.data);\n\t    } else if (token.type === SINGLE) {\n\t      curr.push(token.attr ? [token.tag, token.attr] : [token.tag]);\n\t    } else if (token.type === OPEN) {\n\t      // TODO: some things auto close other things: <td>, <li>, <p>, <table>\n\t      // https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-omission\n\t      var elm = token.attr ? [token.tag, token.attr] : [token.tag];\n\t      curr.push(elm);\n\t      stack.push(elm);\n\t      curr = elm;\n\t    } else if (token.type === CLOSE) {\n\t      if (stack.length) {\n\t        for (var _i = stack.length - 1; _i >= 0; _i--) {\n\t          var head = stack[_i];\n\t          if (head[0] === token.tag) {\n\t            stack.splice(_i);\n\t            curr = stack[stack.length - 1] || root;\n\t            break;\n\t          }\n\t        }\n\t      }\n\t      if (!stack.length && lazy) {\n\t        root.sourceLength = token.pos + token.src.length;\n\t        return root;\n\t      }\n\t    }\n\t  }\n\t  root.sourceLength = token ? token.pos + token.src.length : 0;\n\t  return root;\n\t}\n\t\n\tmodule.exports = {\n\t  singletons: singletons,\n\t  tokenize: tokenize,\n\t  parseHtml: parse,\n\t  parseHtmlAttr: parseHtmlAttr,\n\t  testCloseTag: testCloseTag,\n\t  testOpenTagBlock: testOpenTagBlock,\n\t  testOpenTag: testOpenTag,\n\t  testComment: testComment\n\t};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/*\n\t** Regular Expression helper methods\n\t**\n\t** This provides the `re` object, which contains several helper\n\t** methods for working with big regular expressions (soup).\n\t**\n\t*/\n\t\n\tvar _cache = {};\n\t\n\tvar re = module.exports = {\n\t\n\t  pattern: {\n\t    'punct': '[!-/:-@\\\\[\\\\\\\\\\\\]-`{-~]',\n\t    'space': '\\\\s'\n\t  },\n\t\n\t  escape: function escape(src) {\n\t    return src.replace(/[\\-\\[\\]\\{\\}\\(\\)\\*\\+\\?\\.,\\\\\\^\\$\\|#\\s]/g, '\\\\$&');\n\t  },\n\t\n\t  collapse: function collapse(src) {\n\t    return src.replace(/(?:#.*?(?:\\n|$))/g, '').replace(/\\s+/g, '');\n\t  },\n\t\n\t  expandPatterns: function expandPatterns(src) {\n\t    // TODO: provide escape for patterns: \\[:pattern:] ?\n\t    return src.replace(/\\[:\\s*(\\w+)\\s*:\\]/g, function (m, k) {\n\t      var ex = re.pattern[k];\n\t      if (ex) {\n\t        return re.expandPatterns(ex);\n\t      } else {\n\t        throw new Error('Pattern ' + m + ' not found in ' + src);\n\t      }\n\t    });\n\t  },\n\t\n\t  isRegExp: function isRegExp(r) {\n\t    return Object.prototype.toString.call(r) === '[object RegExp]';\n\t  },\n\t\n\t  compile: function compile(src, flags) {\n\t    if (re.isRegExp(src)) {\n\t      if (arguments.length === 1) {\n\t        // no flags arg provided, use the RegExp one\n\t        flags = (src.global ? 'g' : '') + (src.ignoreCase ? 'i' : '') + (src.multiline ? 'm' : '');\n\t      }\n\t      src = src.source;\n\t    }\n\t    // don't do the same thing twice\n\t    var ckey = src + (flags || '');\n\t    if (ckey in _cache) {\n\t      return _cache[ckey];\n\t    }\n\t    // allow classes\n\t    var rx = re.expandPatterns(src);\n\t    // allow verbose expressions\n\t    if (flags && /x/.test(flags)) {\n\t      rx = re.collapse(rx);\n\t    }\n\t    // allow dotall expressions\n\t    if (flags && /s/.test(flags)) {\n\t      rx = rx.replace(/([^\\\\])\\./g, '$1[^\\\\0]');\n\t    }\n\t    // TODO: test if MSIE and add replace \\s with [\\s\\u00a0] if it is?\n\t    // clean flags and output new regexp\n\t    flags = (flags || '').replace(/[^gim]/g, '');\n\t    return _cache[ckey] = new RegExp(rx, flags);\n\t  }\n\t\n\t};\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function ribbon(feed) {\n\t  var org = String(feed);\n\t  var slot = void 0;\n\t  var pos = 0;\n\t  var self = {\n\t\n\t    index: function index() {\n\t      return pos;\n\t    },\n\t\n\t    save: function save() {\n\t      slot = pos;\n\t      return self;\n\t    },\n\t\n\t    getSlot: function getSlot() {\n\t      return slot || 0;\n\t    },\n\t\n\t    getPos: function getPos() {\n\t      return pos || 0;\n\t    },\n\t\n\t    load: function load() {\n\t      pos = slot;\n\t      feed = org.slice(pos);\n\t      return self;\n\t    },\n\t\n\t    advance: function advance(n) {\n\t      pos += typeof n === 'string' ? n.length : n;\n\t      feed = org.slice(pos);\n\t      return feed;\n\t    },\n\t\n\t    skipWS: function skipWS() {\n\t      var ws = /^\\s+/.exec(feed);\n\t      if (ws) {\n\t        pos += ws[0].length;\n\t        feed = org.slice(pos);\n\t        return ws[0];\n\t      }\n\t      return '';\n\t    },\n\t\n\t    lookbehind: function lookbehind(nchars) {\n\t      nchars = nchars == null ? 1 : nchars;\n\t      return org.slice(pos - nchars, pos);\n\t    },\n\t\n\t    startsWith: function startsWith(s) {\n\t      return feed.substring(0, s.length) === s;\n\t    },\n\t\n\t    slice: function slice(a, b) {\n\t      return b != null ? feed.slice(a, b) : feed.slice(a);\n\t    },\n\t\n\t    valueOf: function valueOf() {\n\t      return feed;\n\t    },\n\t\n\t    toString: function toString() {\n\t      return feed;\n\t    }\n\t\n\t  };\n\t\n\t  return self;\n\t};\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/*\n\t** textile flow content parser\n\t*/\n\tvar builder = __webpack_require__(7);\n\tvar ribbon = __webpack_require__(5);\n\tvar re = __webpack_require__(4);\n\tvar fixLinks = __webpack_require__(8);\n\t\n\tvar _require = __webpack_require__(3),\n\t    parseHtml = _require.parseHtml,\n\t    tokenize = _require.tokenize,\n\t    parseHtmlAttr = _require.parseHtmlAttr,\n\t    singletons = _require.singletons,\n\t    testComment = _require.testComment,\n\t    testOpenTagBlock = _require.testOpenTagBlock;\n\t\n\tvar _require2 = __webpack_require__(9),\n\t    parsePhrase = _require2.parsePhrase;\n\t\n\tvar _require3 = __webpack_require__(10),\n\t    copyAttr = _require3.copyAttr,\n\t    parseAttr = _require3.parseAttr,\n\t    addLineNumber = _require3.addLineNumber;\n\t\n\tvar _require4 = __webpack_require__(13),\n\t    testList = _require4.testList,\n\t    parseList = _require4.parseList;\n\t\n\tvar _require5 = __webpack_require__(14),\n\t    testDefList = _require5.testDefList,\n\t    parseDefList = _require5.parseDefList;\n\t\n\tvar _require6 = __webpack_require__(15),\n\t    testTable = _require6.testTable,\n\t    parseTable = _require6.parseTable;\n\t\n\tvar _require7 = __webpack_require__(12),\n\t    txblocks = _require7.txblocks,\n\t    txlisthd = _require7.txlisthd,\n\t    txattr = _require7.txattr;\n\t\n\tre.pattern.txblocks = txblocks;\n\tre.pattern.txlisthd = txlisthd;\n\tre.pattern.txattr = txattr;\n\t\n\t// HTML tags allowed in the document (root) level that trigger HTML parsing\n\tvar allowedBlocktags = {\n\t  'p': 0,\n\t  'hr': 0,\n\t  'ul': 1,\n\t  'ol': 0,\n\t  'li': 0,\n\t  'div': 1,\n\t  'pre': 0,\n\t  'object': 1,\n\t  'script': 0,\n\t  'noscript': 0,\n\t  'blockquote': 1,\n\t  'notextile': 1\n\t};\n\t\n\tvar reBlock = re.compile(/^([:txblocks:])/);\n\tvar reBlockNormal = re.compile(/^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n(?:\\s*\\n|$)+)/, 's');\n\tvar reBlockExtended = re.compile(/^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n+(?=[:txblocks:][:txattr:]\\.))/, 's');\n\tvar reBlockNormalPre = re.compile(/^(.*?)($|\\r?\\n(?:\\s*\\n|$)+)/, 's');\n\tvar reBlockExtendedPre = re.compile(/^(.*?)($|\\r?\\n+(?=[:txblocks:][:txattr:]\\.))/, 's');\n\t\n\tvar reRuler = /^(\\-\\-\\-+|\\*\\*\\*+|___+)(\\r?\\n\\s+|$)/;\n\tvar reLinkRef = re.compile(/^\\[([^\\]]+)\\]((?:https?:\\/\\/|\\/)\\S+)(?:\\s*\\n|$)/);\n\tvar reFootnoteDef = /^fn\\d+$/;\n\t\n\tvar reCleanBegin = /^( *\\r?\\n)+/;\n\t\n\tvar hasOwn = Object.prototype.hasOwnProperty;\n\tfunction extend(target) {\n\t  for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n\t    args[_key - 1] = arguments[_key];\n\t  }\n\t\n\t  for (var i = 1; i < args.length; i++) {\n\t    var src = args[i];\n\t    if (src != null) {\n\t      for (var nextKey in src) {\n\t        if (hasOwn.call(src, nextKey)) {\n\t          target[nextKey] = src[nextKey];\n\t        }\n\t      }\n\t    }\n\t  }\n\t  return target;\n\t}\n\t\n\tfunction paragraph(s, tag, pba, linebreak, options) {\n\t  tag = tag || 'p';\n\t  var out = [];\n\t  s.split(/(?:\\r?\\n){2,}/).forEach(function (bit, i) {\n\t    if (tag === 'p' && /^\\s/.test(bit)) {\n\t      // no-paragraphs\n\t      bit = bit.replace(/\\r?\\n[\\t ]/g, ' ').trim();\n\t      out = out.concat(parsePhrase(bit, options));\n\t    } else {\n\t      if (linebreak && i) {\n\t        out.push(linebreak);\n\t      }\n\t      out.push(pba ? [tag, pba].concat(parsePhrase(bit, options)) : [tag].concat(parsePhrase(bit, options)));\n\t    }\n\t  });\n\t  return out;\n\t};\n\t\n\tfunction computeCharOffset(src, options, lineOffset) {\n\t  if (options.showOriginalLineNumber) {\n\t    lineOffset = lineOffset || 0;\n\t\n\t    var removedSrc = src.match(reCleanBegin);\n\t    if (removedSrc && removedSrc[0]) {\n\t      lineOffset += (removedSrc[0].match(/\\n/g) || []).length;\n\t    }\n\t    return lineOffset;\n\t  } else {\n\t    return 0;\n\t  }\n\t}\n\t\n\tfunction storeCharPosToLine(src, options, charOffset) {\n\t  // FIXME: don't store all chr ?\n\t  if (options.showOriginalLineNumber) {\n\t    var charPosToLine = [];\n\t    var realSrc = src.toString();\n\t    for (var i in realSrc) {\n\t      charPosToLine[i] = charOffset;\n\t      if (realSrc[i] === '\\n') {\n\t        charOffset++;\n\t      }\n\t    }\n\t    return charPosToLine;\n\t  } else {\n\t    return void 0;\n\t  }\n\t}\n\t\n\tfunction parseFlow(src, options, lineOffset) {\n\t  var list = builder();\n\t\n\t  var linkRefs = void 0;\n\t  var m = void 0;\n\t\n\t  // keep as local variable, for nested calls (->block HTML)\n\t  var charLineOffset = computeCharOffset(src, options, lineOffset);\n\t\n\t  src = ribbon(src.replace(reCleanBegin, ''));\n\t\n\t  // keep as local variable, for nested calls (->block HTML)\n\t  var charPosToLine = storeCharPosToLine(src, options, charLineOffset);\n\t\n\t  // loop\n\t  while (src.valueOf()) {\n\t    src.save();\n\t\n\t    // link_ref -- this goes first because it shouldn't trigger a linebreak\n\t    if (m = reLinkRef.exec(src)) {\n\t      if (!linkRefs) {\n\t        linkRefs = {};\n\t      }\n\t      src.advance(m[0]);\n\t      linkRefs[m[1]] = m[2];\n\t      continue;\n\t    }\n\t\n\t    // add linebreak\n\t    list.linebreak();\n\t\n\t    // named block\n\t    if (m = reBlock.exec(src)) {\n\t      src.advance(m[0]);\n\t      var blockType = m[0];\n\t      var pba = parseAttr(src, blockType);\n\t\n\t      if (pba) {\n\t        src.advance(pba[0]);\n\t        pba = pba[1];\n\t      }\n\t      pba = addLineNumber(pba, options, charPosToLine, 0, src.getSlot());\n\t      if (m = /^\\.(\\.?)(?:\\s|(?=:))/.exec(src)) {\n\t        // FIXME: this whole copyAttr seems rather strange?\n\t        // slurp rest of block\n\t        var extended = !!m[1];\n\t        var reBlockGlob = extended ? reBlockExtended : reBlockNormal;\n\t        if (blockType === 'bc' || blockType === 'pre') {\n\t          reBlockGlob = extended ? reBlockExtendedPre : reBlockNormalPre;\n\t        }\n\t        m = reBlockGlob.exec(src.advance(m[0]));\n\t        src.advance(m[0]);\n\t        // bq | bc | notextile | pre | h# | fn# | p | ###\n\t        if (blockType === 'bq') {\n\t          var inner = m[1];\n\t          if (m = /^:(\\S+)\\s+/.exec(inner)) {\n\t            if (!pba) {\n\t              pba = {};\n\t            }\n\t            pba.cite = m[1];\n\t            inner = inner.slice(m[0].length);\n\t          }\n\t          // RedCloth adds all attr to both: this is bad because it produces duplicate IDs\n\t          var par = paragraph(inner, 'p', copyAttr(pba, { 'cite': 1, 'id': 1 }), '\\n', options);\n\t          list.add(['blockquote', pba, '\\n'].concat(par).concat(['\\n']));\n\t        } else if (blockType === 'bc') {\n\t          var subPba = pba ? copyAttr(pba, { 'id': 1 }) : null;\n\t          list.add(['pre', pba, subPba ? ['code', subPba, m[1]] : ['code', m[1]]]);\n\t        } else if (blockType === 'notextile') {\n\t          list.merge(parseHtml(tokenize(m[1])));\n\t        } else if (blockType === '###') {\n\t          // ignore the insides\n\t        } else if (blockType === 'pre') {\n\t          // I disagree with RedCloth, but agree with PHP here:\n\t          // \"pre(foo#bar).. line1\\n\\nline2\" prevents multiline preformat blocks\n\t          // ...which seems like the whole point of having an extended pre block?\n\t          list.add(['pre', pba, m[1]]);\n\t        } else if (reFootnoteDef.test(blockType)) {\n\t          // footnote\n\t          // Need to be careful: RedCloth fails \"fn1(foo#m). footnote\" -- it confuses the ID\n\t          var fnid = blockType.replace(/\\D+/g, '');\n\t          if (!pba) {\n\t            pba = {};\n\t          }\n\t          pba.class = (pba['class'] ? pba['class'] + ' ' : '') + 'footnote';\n\t          pba.id = 'fn' + fnid;\n\t          list.add(['p', pba, ['a', { 'href': '#fnr' + fnid }, ['sup', fnid]], ' '].concat(parsePhrase(m[1], options)));\n\t        } else {\n\t          // heading | paragraph\n\t          list.merge(paragraph(m[1], blockType, pba, '\\n', options));\n\t        }\n\t        continue;\n\t      } else {\n\t        src.load();\n\t      }\n\t    }\n\t\n\t    // HTML comment\n\t    if (m = testComment(src)) {\n\t      src.advance(m[0] + (/(?:\\s*\\n+)+/.exec(src) || [])[0]);\n\t      list.add(['!', m[1]]);\n\t      continue;\n\t    }\n\t\n\t    // block HTML\n\t    if (m = testOpenTagBlock(src)) {\n\t      var tag = m[1];\n\t\n\t      // Is block tag? ...\n\t      if (tag in allowedBlocktags) {\n\t        if (m[3] || tag in singletons) {\n\t          // single?\n\t          src.advance(m[0]);\n\t          if (/^\\s*(\\n|$)/.test(src)) {\n\t            var elm = [tag];\n\t            if (m[2]) {\n\t              elm.push(parseHtmlAttr(m[2]));\n\t            }\n\t            list.add(elm);\n\t            src.skipWS();\n\t            continue;\n\t          }\n\t        } else if (tag === 'pre') {\n\t          var t = tokenize(src, { 'pre': 1, 'code': 1 }, tag);\n\t          var p = parseHtml(t, true);\n\t          src.load().advance(p.sourceLength);\n\t          if (/^\\s*(\\n|$)/.test(src)) {\n\t            list.merge(p);\n\t            src.skipWS(); // skip tailing whitespace\n\t            continue;\n\t          }\n\t        } else if (tag === 'notextile') {\n\t          // merge all child elements\n\t          var _t = tokenize(src, null, tag);\n\t          var s = 1; // start after open tag\n\t          while (/^\\s+$/.test(_t[s].src)) {\n\t            s++; // skip whitespace\n\t          }\n\t          var _p = parseHtml(_t.slice(s, -1), true);\n\t          var x = _t.pop();\n\t          src.load().advance(x.pos + x.src.length);\n\t          if (/^\\s*(\\n|$)/.test(src)) {\n\t            list.merge(_p);\n\t            src.skipWS(); // skip tailing whitespace\n\t            continue;\n\t          }\n\t        } else {\n\t          src.skipWS();\n\t          var _t2 = tokenize(src, null, tag);\n\t          var _x = _t2.pop(); // this should be the end tag\n\t          var _s = 1; // start after open tag\n\t          while (_t2[_s] && /^[\\n\\r]+$/.test(_t2[_s].src)) {\n\t            _s++; // skip whitespace\n\t          }\n\t          if (_x.tag === tag) {\n\t            // inner can be empty\n\t            var _inner = _t2.length > 1 ? src.slice(_t2[_s].pos, _x.pos) : '';\n\t            src.advance(_x.pos + _x.src.length);\n\t            if (/^\\s*(\\n|$)/.test(src)) {\n\t              var _elm = [tag];\n\t              if (m[2]) {\n\t                _elm.push(parseHtmlAttr(m[2]));\n\t              }\n\t              if (tag === 'script' || tag === 'style') {\n\t                _elm.push(_inner);\n\t              } else {\n\t                var innerHTML = _inner.replace(/^\\n+/, '').replace(/\\s*$/, '');\n\t                var isBlock = /\\n\\r?\\n/.test(innerHTML) || tag === 'ol' || tag === 'ul';\n\t                var innerElm = isBlock ? parseFlow(innerHTML, options) : parsePhrase(innerHTML, extend({}, options, { breaks: false }));\n\t                if (isBlock || /^\\n/.test(_inner)) {\n\t                  _elm.push('\\n');\n\t                }\n\t                if (isBlock || /\\s$/.test(_inner)) {\n\t                  innerElm.push('\\n');\n\t                }\n\t                _elm = _elm.concat(innerElm);\n\t              }\n\t\n\t              list.add(_elm);\n\t              src.skipWS(); // skip tailing whitespace\n\t              continue;\n\t            }\n\t          }\n\t        }\n\t      }\n\t      src.load();\n\t    }\n\t\n\t    // ruler\n\t    if (m = reRuler.exec(src)) {\n\t      src.advance(m[0]);\n\t      list.add(['hr']);\n\t      continue;\n\t    }\n\t\n\t    // list\n\t    if (m = testList(src)) {\n\t      src.advance(m[0]);\n\t      list.add(parseList(m[0], options, src.getSlot(), charPosToLine));\n\t      continue;\n\t    }\n\t\n\t    // definition list\n\t    if (m = testDefList(src)) {\n\t      src.advance(m[0]);\n\t      list.add(parseDefList(m[0], options, src.getSlot(), charPosToLine));\n\t      continue;\n\t    }\n\t\n\t    // table\n\t    if (m = testTable(src)) {\n\t      src.advance(m[0]);\n\t      list.add(parseTable(m[1], options, src.getSlot(), charPosToLine));\n\t      continue;\n\t    }\n\t\n\t    // paragraph\n\t    m = reBlockNormal.exec(src);\n\t    list.merge(paragraph(m[1], 'p', addLineNumber({}, options, charPosToLine, 0, src.getSlot()), '\\n', options));\n\t    src.advance(m[0]);\n\t  }\n\t\n\t  return linkRefs ? fixLinks(list.get(), linkRefs) : list.get();\n\t}\n\t\n\texports.parseFlow = parseFlow;\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tmodule.exports = function builder(initArr) {\n\t  var arr = Array.isArray(initArr) ? initArr : [];\n\t\n\t  return {\n\t    add: function add(node) {\n\t      if (typeof node === 'string' && typeof arr[arr.length - 1] === 'string') {\n\t        // join if possible\n\t        arr[arr.length - 1] += node;\n\t      } else if (Array.isArray(node)) {\n\t        arr.push(node.filter(function (s) {\n\t          return s !== undefined;\n\t        }));\n\t      } else if (node) {\n\t        arr.push(node);\n\t      }\n\t      return this;\n\t    },\n\t\n\t    merge: function merge(arr) {\n\t      for (var i = 0, l = arr.length; i < l; i++) {\n\t        this.add(arr[i]);\n\t      }\n\t      return this;\n\t    },\n\t\n\t    linebreak: function linebreak() {\n\t      if (arr.length) {\n\t        this.add('\\n');\n\t      }\n\t    },\n\t\n\t    get: function get() {\n\t      return arr;\n\t    }\n\t  };\n\t};\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\t// recurse the tree and swap out any \"href\" attributes\n\t// this uses the context as the replace dictionary so it can be fed to Array#map\n\tmodule.exports = function fixLinks(ml, dict) {\n\t  if (Array.isArray(ml)) {\n\t    if (ml[0] === 'a') {\n\t      // found a link\n\t      var attr = ml[1];\n\t      if ((typeof attr === 'undefined' ? 'undefined' : _typeof(attr)) === 'object' && 'href' in attr && attr.href in dict) {\n\t        attr.href = dict[attr.href];\n\t      }\n\t    }\n\t    for (var i = 0, l = ml.length; i < l; i++) {\n\t      if (Array.isArray(ml[i])) {\n\t        fixLinks(ml[i], dict);\n\t      }\n\t    }\n\t  }\n\t  return ml;\n\t};\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* textile inline parser */\n\t\n\tvar ribbon = __webpack_require__(5);\n\tvar builder = __webpack_require__(7);\n\tvar re = __webpack_require__(4);\n\t\n\tvar _require = __webpack_require__(10),\n\t    parseAttr = _require.parseAttr;\n\t\n\tvar _require2 = __webpack_require__(11),\n\t    parseGlyph = _require2.parseGlyph;\n\t\n\tvar _require3 = __webpack_require__(3),\n\t    parseHtml = _require3.parseHtml,\n\t    parseHtmlAttr = _require3.parseHtmlAttr,\n\t    tokenize = _require3.tokenize,\n\t    singletons = _require3.singletons,\n\t    testComment = _require3.testComment,\n\t    testOpenTag = _require3.testOpenTag;\n\t\n\tvar _require4 = __webpack_require__(12),\n\t    ucaps = _require4.ucaps,\n\t    txattr = _require4.txattr,\n\t    txcite = _require4.txcite;\n\t\n\tre.pattern.txattr = txattr;\n\tre.pattern.txcite = txcite;\n\tre.pattern.ucaps = ucaps;\n\t\n\tvar phraseConvert = {\n\t  '*': 'strong',\n\t  '**': 'b',\n\t  '??': 'cite',\n\t  '_': 'em',\n\t  '__': 'i',\n\t  '-': 'del',\n\t  '%': 'span',\n\t  '+': 'ins',\n\t  '~': 'sub',\n\t  '^': 'sup',\n\t  '@': 'code'\n\t};\n\t\n\tvar rePhrase = /^([\\[\\{]?)(__?|\\*\\*?|\\?\\?|[\\-\\+\\^~@%])/;\n\tvar reImage = re.compile(/^!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^\\.\\/]))?)([^!\\s]+?) ?(?:\\(((?:[^\\(\\)]|\\([^\\(\\)]+\\))+)\\))?!(?::([^\\s]+?(?=[!-\\.:-@\\[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?/);\n\tvar reImageFenced = re.compile(/^\\[!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^\\.\\/]))?)([^!\\s]+?) ?(?:\\(((?:[^\\(\\)]|\\([^\\(\\)]+\\))+)\\))?!(?::([^\\s]+?(?=[!-\\.:-@\\[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?\\]/);\n\t// NB: there is an exception in here to prevent matching \"TM)\"\n\tvar reCaps = re.compile(/^((?!TM\\)|tm\\))[[:ucaps:]](?:[[:ucaps:]\\d]{1,}(?=\\()|[[:ucaps:]\\d]{2,}))(?:\\((.*?)\\))?(?=\\W|$)/);\n\tvar reLink = re.compile(/^\"(?!\\s)((?:[^\"]|\"(?![\\s:])[^\\n\"]+\"(?!:))+)\"[:txcite:]/);\n\tvar reLinkFenced = /^\\[\"([^\\n]+?)\":((?:\\[[a-z0-9]*\\]|[^\\]])+)\\]/;\n\tvar reLinkTitle = /\\s*\\(((?:\\([^\\(\\)]*\\)|[^\\(\\)])+)\\)$/;\n\tvar reFootnote = /^\\[(\\d+)(!?)\\]/;\n\t\n\tfunction parsePhrase(src, options) {\n\t  src = ribbon(src);\n\t  var list = builder();\n\t  var m = void 0;\n\t  var pba = void 0;\n\t\n\t  // loop\n\t  do {\n\t    src.save();\n\t\n\t    // linebreak -- having this first keeps it from messing to much with other phrases\n\t    if (src.startsWith('\\r\\n')) {\n\t      src.advance(1); // skip cartridge returns\n\t    }\n\t    if (src.startsWith('\\n')) {\n\t      src.advance(1);\n\t      if (src.startsWith(' ')) {\n\t        src.advance(1);\n\t      } else if (options.breaks) {\n\t        list.add(['br']);\n\t      }\n\t      list.add('\\n');\n\t      continue;\n\t    }\n\t\n\t    // inline notextile\n\t    if (m = /^==(.*?)==/.exec(src)) {\n\t      src.advance(m[0]);\n\t      list.add(m[1]);\n\t      continue;\n\t    }\n\t\n\t    // lookbehind => /([\\s>.,\"'?!;:])$/\n\t    var behind = src.lookbehind(1);\n\t    var boundary = !behind || /^[\\s>.,\"'?!;:()]$/.test(behind);\n\t    // FIXME: need to test right boundary for phrases as well\n\t    if ((m = rePhrase.exec(src)) && (boundary || m[1])) {\n\t      src.advance(m[0]);\n\t      var tok = m[2];\n\t      var fence = m[1];\n\t      var phraseType = phraseConvert[tok];\n\t      var code = phraseType === 'code';\n\t\n\t      if (pba = !code && parseAttr(src, phraseType, tok)) {\n\t        src.advance(pba[0]);\n\t        pba = pba[1];\n\t      }\n\t      // FIXME: if we can't match the fence on the end, we should output fence-prefix as normal text\n\t      // seek end\n\t      var mMid = void 0;\n\t      var mEnd = void 0;\n\t      if (fence === '[') {\n\t        mMid = '^(.*?)';\n\t        mEnd = '(?:])';\n\t      } else if (fence === '{') {\n\t        mMid = '^(.*?)';\n\t        mEnd = '(?:})';\n\t      } else {\n\t        var t1 = re.escape(tok.charAt(0));\n\t        mMid = code ? '^(\\\\S+|\\\\S+.*?\\\\S)' : '^([^\\\\s' + t1 + ']+|[^\\\\s' + t1 + '].*?\\\\S(' + t1 + '*))';\n\t        mEnd = '(?=$|[\\\\s.,\"\\'!?;:()«»„“”‚‘’])';\n\t      }\n\t      var rx = re.compile(mMid + '(' + re.escape(tok) + ')' + mEnd);\n\t      if ((m = rx.exec(src)) && m[1]) {\n\t        src.advance(m[0]);\n\t        if (code) {\n\t          list.add([phraseType, m[1]]);\n\t        } else {\n\t          list.add([phraseType, pba].concat(parsePhrase(m[1], options)));\n\t        }\n\t        continue;\n\t      }\n\t      // else\n\t      src.load();\n\t    }\n\t\n\t    // image\n\t    if ((m = reImage.exec(src)) || (m = reImageFenced.exec(src))) {\n\t      src.advance(m[0]);\n\t\n\t      pba = m[1] && parseAttr(m[1], 'img');\n\t      var attr = pba ? pba[1] : { 'src': '' };\n\t      var img = ['img', attr];\n\t      attr.src = m[2];\n\t      attr.alt = m[3] ? attr.title = m[3] : '';\n\t\n\t      if (m[4]) {\n\t        // +cite causes image to be wraped with a link (or link_ref)?\n\t        // TODO: support link_ref for image cite\n\t        img = ['a', { 'href': m[4] }, img];\n\t      }\n\t      list.add(img);\n\t      continue;\n\t    }\n\t\n\t    // html comment\n\t    if (m = testComment(src)) {\n\t      src.advance(m[0]);\n\t      list.add(['!', m[1]]);\n\t      continue;\n\t    }\n\t    // html tag\n\t    // TODO: this seems to have a lot of overlap with block tags... DRY?\n\t    if (m = testOpenTag(src)) {\n\t      src.advance(m[0]);\n\t      var tag = m[1];\n\t      var single = m[3] || m[1] in singletons;\n\t      var element = [tag];\n\t      if (m[2]) {\n\t        element.push(parseHtmlAttr(m[2]));\n\t      }\n\t      if (single) {\n\t        // single tag\n\t        list.add(element).add(src.skipWS());\n\t        continue;\n\t      } else {\n\t        // need terminator\n\t        // gulp up the rest of this block...\n\t        var reEndTag = re.compile('^(.*?)(</' + tag + '\\\\s*>)', 's');\n\t        if (m = reEndTag.exec(src)) {\n\t          src.advance(m[0]);\n\t          if (tag === 'code') {\n\t            element.push(m[1]);\n\t          } else if (tag === 'notextile') {\n\t            // HTML is still parsed, even though textile is not\n\t            list.merge(parseHtml(tokenize(m[1])));\n\t            continue;\n\t          } else {\n\t            element = element.concat(parsePhrase(m[1], options));\n\t          }\n\t          list.add(element);\n\t          continue;\n\t        }\n\t        // end tag is missing, treat tag as normal text...\n\t      }\n\t      src.load();\n\t    }\n\t\n\t    // footnote\n\t    if ((m = reFootnote.exec(src)) && /\\S/.test(behind)) {\n\t      src.advance(m[0]);\n\t      list.add(['sup', { 'class': 'footnote', 'id': 'fnr' + m[1] }, m[2] === '!' ? m[1] // \"!\" suppresses the link\n\t      : ['a', { href: '#fn' + m[1] }, m[1]]]);\n\t      continue;\n\t    }\n\t\n\t    // caps / abbr\n\t    if (m = reCaps.exec(src)) {\n\t      src.advance(m[0]);\n\t      var caps = ['span', { 'class': 'caps' }, m[1]];\n\t      if (m[2]) {\n\t        // FIXME: use <abbr>, not acronym!\n\t        caps = ['acronym', { 'title': m[2] }, caps];\n\t      }\n\t      list.add(caps);\n\t      continue;\n\t    }\n\t\n\t    // links\n\t    if (boundary && (m = reLink.exec(src)) || (m = reLinkFenced.exec(src))) {\n\t      src.advance(m[0]);\n\t      var title = m[1].match(reLinkTitle);\n\t      var inner = title ? m[1].slice(0, m[1].length - title[0].length) : m[1];\n\t      if (pba = parseAttr(inner, 'a')) {\n\t        inner = inner.slice(pba[0]);\n\t        pba = pba[1];\n\t      } else {\n\t        pba = {};\n\t      }\n\t      if (title && !inner) {\n\t        inner = title[0];\n\t        title = '';\n\t      }\n\t      pba.href = m[2];\n\t      if (title) {\n\t        pba.title = title[1];\n\t      }\n\t      list.add(['a', pba].concat(parsePhrase(inner.replace(/^(\\.?\\s*)/, ''), options)));\n\t      continue;\n\t    }\n\t\n\t    // no match, move by all \"uninteresting\" chars\n\t    m = /([a-zA-Z0-9,.':]+|[ \\f\\r\\t\\v\\xA0\\u2028\\u2029]+|[^\\0])/.exec(src);\n\t    if (m) {\n\t      list.add(m[0]);\n\t    }\n\t    src.advance(m ? m[0].length || 1 : 1);\n\t  } while (src.valueOf());\n\t\n\t  return list.get().map(parseGlyph);\n\t}\n\t\n\texports.parsePhrase = parsePhrase;\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\tvar reClassid = /^\\(([^\\(\\)\\n]+)\\)/;\n\tvar rePaddingL = /^(\\(+)/;\n\tvar rePaddingR = /^(\\)+)/;\n\tvar reAlignBlock = /^(<>|<|>|=)/;\n\tvar reAlignImg = /^(<|>|=)/;\n\tvar reVAlign = /^(~|\\^|\\-)/;\n\tvar reColSpan = /^\\\\(\\d+)/;\n\tvar reRowSpan = /^\\/(\\d+)/;\n\tvar reStyles = /^\\{([^\\}]*)\\}/;\n\tvar reCSS = /^\\s*([^:\\s]+)\\s*:\\s*(.+)\\s*$/;\n\tvar reLang = /^\\[([^\\[\\]\\n]+)\\]/;\n\t\n\tvar pbaAlignLookup = {\n\t  '<': 'left',\n\t  '=': 'center',\n\t  '>': 'right',\n\t  '<>': 'justify'\n\t};\n\t\n\tvar pbaVAlignLookup = {\n\t  '~': 'bottom',\n\t  '^': 'top',\n\t  '-': 'middle'\n\t};\n\t\n\tfunction copyAttr(s, blacklist) {\n\t  if (!s) {\n\t    return undefined;\n\t  }\n\t  var d = {};\n\t  for (var k in s) {\n\t    if (k in s && (!blacklist || !(k in blacklist))) {\n\t      d[k] = s[k];\n\t    }\n\t  }\n\t  return d;\n\t}\n\t\n\tfunction testBlock(name) {\n\t  // \"in\" test would be better but what about fn#.?\n\t  return (/^(?:table|t[dh]|t(?:foot|head|body)|b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)$/.test(name)\n\t  );\n\t}\n\t\n\t/*\n\t  The attr bit causes massive problems for span elements when parentheses are used.\n\t  Parentheses are a total mess and, unsurprisingly, cause trip-ups:\n\t\n\t   RC: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\" class=\"span\">(span) span (span)</em>`\n\t   PHP: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\">(span) span (span)</em>`\n\t\n\t  PHP and RC seem to mostly solve this by not parsing a final attr parens on spans if the\n\t  following character is a non-space. I've duplicated that: Class/ID is not matched on spans\n\t  if it is followed by `endToken` or <space>.\n\t\n\t  Lang is not matched here if it is followed by the end token. Theoretically I could limit the lang\n\t  attribute to /^\\[[a-z]{2+}(\\-[a-zA-Z0-9]+)*\\]/ because Textile is layered on top of HTML which\n\t  only accepts valid BCP 47 language tags, but who knows what atrocities are being preformed\n\t  out there in the real world. So this attempts to emulate the other libraries.\n\t*/\n\tfunction parseAttr(input, element, endToken) {\n\t  input = String(input);\n\t  if (!input || element === 'notextile') {\n\t    return undefined;\n\t  }\n\t\n\t  var m = void 0;\n\t  var st = {};\n\t  var o = { 'style': st };\n\t  var remaining = input;\n\t\n\t  var isBlock = testBlock(element);\n\t  var isImg = element === 'img';\n\t  var isList = element === 'li';\n\t  var isPhrase = !isBlock && !isImg && element !== 'a';\n\t  var reAlign = isImg ? reAlignImg : reAlignBlock;\n\t\n\t  do {\n\t    if (m = reStyles.exec(remaining)) {\n\t      m[1].split(';').forEach(function (p) {\n\t        var d = p.match(reCSS);\n\t        if (d) {\n\t          st[d[1]] = d[2];\n\t        }\n\t      });\n\t      remaining = remaining.slice(m[0].length);\n\t      continue;\n\t    }\n\t\n\t    if (m = reLang.exec(remaining)) {\n\t      var rm = remaining.slice(m[0].length);\n\t      if (!rm && isPhrase || endToken && endToken === rm.slice(0, endToken.length)) {\n\t        m = null;\n\t      } else {\n\t        o['lang'] = m[1];\n\t        remaining = remaining.slice(m[0].length);\n\t      }\n\t      continue;\n\t    }\n\t\n\t    if (m = reClassid.exec(remaining)) {\n\t      var _rm = remaining.slice(m[0].length);\n\t      if (!_rm && isPhrase || endToken && (_rm[0] === ' ' || endToken === _rm.slice(0, endToken.length))) {\n\t        m = null;\n\t      } else {\n\t        var bits = m[1].split('#');\n\t        if (bits[0]) {\n\t          o.class = bits[0];\n\t        }\n\t        if (bits[1]) {\n\t          o.id = bits[1];\n\t        }\n\t        remaining = _rm;\n\t      }\n\t      continue;\n\t    }\n\t\n\t    if (isBlock || isList) {\n\t      if (m = rePaddingL.exec(remaining)) {\n\t        st['padding-left'] = m[1].length + 'em';\n\t        remaining = remaining.slice(m[0].length);\n\t        continue;\n\t      }\n\t      if (m = rePaddingR.exec(remaining)) {\n\t        st['padding-right'] = m[1].length + 'em';\n\t        remaining = remaining.slice(m[0].length);\n\t        continue;\n\t      }\n\t    }\n\t\n\t    // only for blocks:\n\t    if (isImg || isBlock || isList) {\n\t      if (m = reAlign.exec(remaining)) {\n\t        var align = pbaAlignLookup[m[1]];\n\t        if (isImg) {\n\t          o['align'] = align;\n\t        } else {\n\t          st['text-align'] = align;\n\t        }\n\t        remaining = remaining.slice(m[0].length);\n\t        continue;\n\t      }\n\t    }\n\t\n\t    // only for table cells\n\t    if (element === 'td' || element === 'tr') {\n\t      if (m = reVAlign.exec(remaining)) {\n\t        st['vertical-align'] = pbaVAlignLookup[m[1]];\n\t        remaining = remaining.slice(m[0].length);\n\t        continue;\n\t      }\n\t    }\n\t    if (element === 'td') {\n\t      if (m = reColSpan.exec(remaining)) {\n\t        o['colspan'] = m[1];\n\t        remaining = remaining.slice(m[0].length);\n\t        continue;\n\t      }\n\t      if (m = reRowSpan.exec(remaining)) {\n\t        o['rowspan'] = m[1];\n\t        remaining = remaining.slice(m[0].length);\n\t        continue;\n\t      }\n\t    }\n\t  } while (m);\n\t\n\t  // collapse styles\n\t  var s = [];\n\t  for (var v in st) {\n\t    s.push(v + ':' + st[v]);\n\t  }\n\t  if (s.length) {\n\t    o.style = s.join(';');\n\t  } else {\n\t    delete o.style;\n\t  }\n\t\n\t  return remaining === input ? undefined : [input.length - remaining.length, o];\n\t}\n\t\n\tfunction addLineNumber(jsonmlEntryAttr, options, charPosToLine, charOffset, charPos) {\n\t  if (options.showOriginalLineNumber && charPosToLine) {\n\t    charOffset = charOffset || 0;\n\t    if (!jsonmlEntryAttr) {\n\t      jsonmlEntryAttr = {};\n\t    }\n\t    jsonmlEntryAttr['data-line'] = charPosToLine[charOffset + charPos];\n\t    if (options.cssClassOriginalLineNumber) {\n\t      jsonmlEntryAttr['class'] = (jsonmlEntryAttr['class'] ? jsonmlEntryAttr['class'] + ' ' : '') + options.cssClassOriginalLineNumber;\n\t    }\n\t  }\n\t  return jsonmlEntryAttr;\n\t}\n\t\n\tmodule.exports = {\n\t  copyAttr: copyAttr,\n\t  parseAttr: parseAttr,\n\t  addLineNumber: addLineNumber\n\t};\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* textile glyph parser */\n\t\n\tvar re = __webpack_require__(4);\n\t\n\tvar reApostrophe = /(\\w)'(\\w)/g;\n\tvar reArrow = /([^\\-]|^)->/;\n\tvar reClosingDQuote = re.compile(/([^\\s\\[\\(])\"(?=$|\\s|[:punct:])/g);\n\tvar reClosingSQuote = re.compile(/([^\\s\\[\\(])'(?=$|\\s|[:punct:])/g);\n\tvar reCopyright = /(\\b ?|\\s|^)(?:\\(C\\)|\\[C\\])/gi;\n\tvar reDimsign = /([\\d\\.,]+['\"]? ?)x( ?)(?=[\\d\\.,]['\"]?)/g;\n\tvar reDoublePrime = re.compile(/(\\d*[\\.,]?\\d+)\"(?=\\s|$|[:punct:])/g);\n\tvar reEllipsis = /([^.]?)\\.{3}/g;\n\tvar reEmdash = /(^|[\\s\\w])--([\\s\\w]|$)/g;\n\tvar reEndash = / - /g;\n\tvar reOpenDQuote = /\"/g;\n\tvar reOpenSQuote = /'/g;\n\tvar reRegistered = /(\\b ?|\\s|^)(?:\\(R\\)|\\[R\\])/gi;\n\tvar reSinglePrime = re.compile(/(\\d*[\\.,]?\\d+)'(?=\\s|$|[:punct:])/g);\n\tvar reTrademark = /(\\b ?|\\s|^)(?:\\((?:TM|tm)\\)|\\[(?:TM|tm)\\])/g;\n\t\n\texports.parseGlyph = function parseGlyph(src) {\n\t  if (typeof src !== 'string') {\n\t    return src;\n\t  }\n\t  // NB: order is important here ...\n\t  return src.replace(reArrow, '$1&#8594;').replace(reDimsign, '$1&#215;$2').replace(reEllipsis, '$1&#8230;').replace(reEmdash, '$1&#8212;$2').replace(reEndash, ' &#8211; ').replace(reTrademark, '$1&#8482;').replace(reRegistered, '$1&#174;').replace(reCopyright, '$1&#169;')\n\t  // double quotes\n\t  .replace(reDoublePrime, '$1&#8243;').replace(reClosingDQuote, '$1&#8221;').replace(reOpenDQuote, '&#8220;')\n\t  // single quotes\n\t  .replace(reSinglePrime, '$1&#8242;').replace(reApostrophe, '$1&#8217;$2').replace(reClosingSQuote, '$1&#8217;').replace(reOpenSQuote, '&#8216;')\n\t  // fractions and degrees\n\t  .replace(/[\\(\\[]1\\/4[\\]\\)]/, '&#188;').replace(/[\\(\\[]1\\/2[\\]\\)]/, '&#189;').replace(/[\\(\\[]3\\/4[\\]\\)]/, '&#190;').replace(/[\\(\\[]o[\\]\\)]/, '&#176;').replace(/[\\(\\[]\\+\\/\\-[\\]\\)]/, '&#177;');\n\t};\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports) {\n\n\t'use strict';\n\t\n\t/* eslint camelcase: 0 */\n\t\n\texports.txblocks = '(?:b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)';\n\t\n\texports.ucaps = 'A-Z' +\n\t// Latin extended À-Þ\n\t'\\xC0-\\xD6\\xD8-\\xDE' +\n\t// Latin caps with embelishments and ligatures...\n\t'\\u0100\\u0102\\u0104\\u0106\\u0108\\u010A\\u010C\\u010E\\u0110\\u0112\\u0114\\u0116\\u0118\\u011A\\u011C\\u011E\\u0120\\u0122\\u0124\\u0126\\u0128\\u012A\\u012C\\u012E\\u0130\\u0132\\u0134\\u0136\\u0139\\u013B\\u013D\\u013F' + '\\u0141\\u0143\\u0145\\u0147\\u014A\\u014C\\u014E\\u0150\\u0152\\u0154\\u0156\\u0158\\u015A\\u015C\\u015E\\u0160\\u0162\\u0164\\u0166\\u0168\\u016A\\u016C\\u016E\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017B\\u017D' + '\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018B\\u018E-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019C\\u019D\\u019F\\u01A0\\u01A2\\u01A4\\u01A6\\u01A7\\u01A9\\u01AC\\u01AE\\u01AF\\u01B1-\\u01B3\\u01B5\\u01B7\\u01B8\\u01BC' + '\\u01C4\\u01C7\\u01CA\\u01CD\\u01CF\\u01D1\\u01D3\\u01D5\\u01D7\\u01D9\\u01DB\\u01DE\\u01E0\\u01E2\\u01E4\\u01E6\\u01E8\\u01EA\\u01EC\\u01EE\\u01F1\\u01F4\\u01F6-\\u01F8\\u01FA\\u01FC\\u01FE' + '\\u0200\\u0202\\u0204\\u0206\\u0208\\u020A\\u020C\\u020E\\u0210\\u0212\\u0214\\u0216\\u0218\\u021A\\u021C\\u021E\\u0220\\u0222\\u0224\\u0226\\u0228\\u022A\\u022C\\u022E\\u0230\\u0232\\u023A\\u023B\\u023D\\u023E' + '\\u0241\\u0243-\\u0246\\u0248\\u024A\\u024C\\u024E' + '\\u1E00\\u1E02\\u1E04\\u1E06\\u1E08\\u1E0A\\u1E0C\\u1E0E\\u1E10\\u1E12\\u1E14\\u1E16\\u1E18\\u1E1A\\u1E1C\\u1E1E\\u1E20\\u1E22\\u1E24\\u1E26\\u1E28\\u1E2A\\u1E2C\\u1E2E\\u1E30\\u1E32\\u1E34\\u1E36\\u1E38\\u1E3A\\u1E3C\\u1E3E\\u1E40' + '\\u1E42\\u1E44\\u1E46\\u1E48\\u1E4A\\u1E4C\\u1E4E\\u1E50\\u1E52\\u1E54\\u1E56\\u1E58\\u1E5A\\u1E5C\\u1E5E\\u1E60\\u1E62\\u1E64\\u1E66\\u1E68\\u1E6A\\u1E6C\\u1E6E\\u1E70\\u1E72\\u1E74\\u1E76\\u1E78\\u1E7A\\u1E7C\\u1E7E' + '\\u1E80\\u1E82\\u1E84\\u1E86\\u1E88\\u1E8A\\u1E8C\\u1E8E\\u1E90\\u1E92\\u1E94\\u1E9E\\u1EA0\\u1EA2\\u1EA4\\u1EA6\\u1EA8\\u1EAA\\u1EAC\\u1EAE\\u1EB0\\u1EB2\\u1EB4\\u1EB6\\u1EB8\\u1EBA\\u1EBC\\u1EBE' + '\\u1EC0\\u1EC2\\u1EC4\\u1EC6\\u1EC8\\u1ECA\\u1ECC\\u1ECE\\u1ED0\\u1ED2\\u1ED4\\u1ED6\\u1ED8\\u1EDA\\u1EDC\\u1EDE\\u1EE0\\u1EE2\\u1EE4\\u1EE6\\u1EE8\\u1EEA\\u1EEC\\u1EEE\\u1EF0\\u1EF2\\u1EF4\\u1EF6\\u1EF8\\u1EFA\\u1EFC\\u1EFE' + '\\u2C60\\u2C62-\\u2C64\\u2C67\\u2C69\\u2C6B\\u2C6D-\\u2C70\\u2C72\\u2C75\\u2C7E\\u2C7F' + '\\uA722\\uA724\\uA726\\uA728\\uA72A\\uA72C\\uA72E\\uA732\\uA734\\uA736\\uA738\\uA73A\\uA73C\\uA73E' + '\\uA740\\uA742\\uA744\\uA746\\uA748\\uA74A\\uA74C\\uA74E\\uA750\\uA752\\uA754\\uA756\\uA758\\uA75A\\uA75C\\uA75E\\uA760\\uA762\\uA764\\uA766\\uA768\\uA76A\\uA76C\\uA76E\\uA779\\uA77B\\uA77D\\uA77E' + '\\uA780\\uA782\\uA784\\uA786\\uA78B\\uA78D\\uA790\\uA792\\uA7A0\\uA7A2\\uA7A4\\uA7A6\\uA7A8\\uA7AA';\n\t\n\texports.txcite = ':((?:[^\\\\s()]|\\\\([^\\\\s()]+\\\\)|[()])+?)(?=[!-\\\\.:-@\\\\[\\\\\\\\\\\\]-`{-~]+(?:$|\\\\s)|$|\\\\s)';\n\t\n\tvar attr_class = exports.attr_class = '\\\\([^\\\\)]+\\\\)';\n\tvar attr_style = exports.attr_style = '\\\\{[^\\\\}]+\\\\}';\n\tvar attr_lang = exports.attr_lang = '\\\\[[^\\\\[\\\\]]+\\\\]';\n\tvar attr_align = exports.attr_align = '(?:<>|<|>|=)';\n\tvar attr_pad = exports.attr_pad = '[\\\\(\\\\)]+';\n\t\n\tvar txattr = exports.txattr = '(?:' + attr_class + '|' + attr_style + '|' + attr_lang + '|' + attr_align + '|' + attr_pad + ')*';\n\t\n\texports.txlisthd = '[\\\\t ]*[\\\\#\\\\*]*(\\\\*|\\\\#(?:_|\\\\d+)?)' + txattr + '(?: +\\\\S|\\\\.\\\\s*(?=\\\\S|\\\\n))';\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* textile list parser */\n\tvar ribbon = __webpack_require__(5);\n\tvar re = __webpack_require__(4);\n\tvar merge = __webpack_require__(1);\n\t\n\tvar _require = __webpack_require__(10),\n\t    parseAttr = _require.parseAttr,\n\t    addLineNumber = _require.addLineNumber;\n\t\n\tvar _require2 = __webpack_require__(9),\n\t    parsePhrase = _require2.parsePhrase;\n\t\n\tvar _require3 = __webpack_require__(12),\n\t    txlisthd = _require3.txlisthd;\n\t\n\tre.pattern.txlisthd = txlisthd;\n\tvar reList = re.compile(/^((?:[:txlisthd:][^\\0]*?(?:\\r?\\n|$))+)(\\s*\\n|$)/, 's');\n\tvar reItem = re.compile(/^([#\\*]+)([^\\0]+?)(\\n(?=[:txlisthd:])|$)/, 's');\n\t\n\tfunction listPad(n) {\n\t  var s = '\\n';\n\t  while (n--) {\n\t    s += '\\t';\n\t  }\n\t  return s;\n\t}\n\t\n\tfunction testList(src) {\n\t  return reList.exec(src);\n\t}\n\t\n\tfunction parseList(src, options, charOffset, charPosToLine) {\n\t  if (options.showOriginalLineNumber) {\n\t    var removedSrc = src.match(/(^|\\r?\\n)[\\t ]+/);\n\t    if (removedSrc && removedSrc[0]) {\n\t      charOffset++;\n\t    }\n\t  }\n\t  src = ribbon(src.replace(/(^|\\r?\\n)[\\t ]+/, '$1'));\n\t\n\t  var stack = [];\n\t  var currIndex = {};\n\t  var lastIndex = options._lst || {};\n\t  var itemIndex = 0;\n\t  var listAttr = void 0;\n\t  var m = void 0;\n\t  var n = void 0;\n\t  var s = void 0;\n\t\n\t  while (m = reItem.exec(src)) {\n\t    var item = ['li'];\n\t    var destLevel = m[1].length;\n\t    var type = m[1].substr(-1) === '#' ? 'ol' : 'ul';\n\t    var newLi = null;\n\t    var lst = void 0;\n\t    var par = void 0;\n\t    var pba = void 0;\n\t    var r = void 0;\n\t\n\t    // list starts and continuations\n\t    if (n = /^(_|\\d+)/.exec(m[2])) {\n\t      itemIndex = isFinite(n[1]) ? parseInt(n[1], 10) : lastIndex[destLevel] || currIndex[destLevel] || 1;\n\t      m[2] = m[2].slice(n[1].length);\n\t    }\n\t\n\t    if (pba = parseAttr(m[2], 'li')) {\n\t      m[2] = m[2].slice(pba[0]);\n\t      pba = pba[1];\n\t    }\n\t\n\t    pba = addLineNumber(pba, options, charPosToLine, charOffset, src.getPos());\n\t\n\t    // list control\n\t    if (/^\\.\\s*$/.test(m[2])) {\n\t      listAttr = pba || {};\n\t      src.advance(m[0]);\n\t      continue;\n\t    }\n\t\n\t    // create nesting until we have correct level\n\t    while (stack.length < destLevel) {\n\t      // list always has an attribute object, this simplifies first-pba resolution\n\t      lst = [type, {}, listPad(stack.length + 1), newLi = ['li']];\n\t      par = stack[stack.length - 1];\n\t      if (par) {\n\t        par.li.push(listPad(stack.length));\n\t        par.li.push(lst);\n\t      }\n\t      stack.push({\n\t        ul: lst,\n\t        li: newLi,\n\t        // count attributes's found per list\n\t        att: 0\n\t      });\n\t      currIndex[stack.length] = 1;\n\t    }\n\t\n\t    // remove nesting until we have correct level\n\t    while (stack.length > destLevel) {\n\t      r = stack.pop();\n\t      r.ul.push(listPad(stack.length));\n\t      // lists have a predictable structure - move pba from listitem to list\n\t      if (r.att === 1 && !r.ul[3][1].substr) {\n\t        merge(r.ul[1], r.ul[3].splice(1, 1)[0]);\n\t      }\n\t    }\n\t\n\t    // parent list\n\t    par = stack[stack.length - 1];\n\t\n\t    if (itemIndex) {\n\t      par.ul[1].start = itemIndex;\n\t      currIndex[destLevel] = itemIndex;\n\t      // falsy prevents this from fireing until it is set again\n\t      itemIndex = 0;\n\t    }\n\t    if (listAttr) {\n\t      // \"more than 1\" prevent attribute transfers on list close\n\t      par.att = 9;\n\t      merge(par.ul[1], listAttr);\n\t      listAttr = null;\n\t    }\n\t\n\t    if (!newLi) {\n\t      par.ul.push(listPad(stack.length), item);\n\t      par.li = item;\n\t    }\n\t    if (pba) {\n\t      par.li.push(pba);\n\t      par.att++;\n\t    }\n\t    Array.prototype.push.apply(par.li, parsePhrase(m[2].trim(), options));\n\t\n\t    src.advance(m[0]);\n\t    currIndex[destLevel] = (currIndex[destLevel] || 0) + 1;\n\t  }\n\t\n\t  // remember indexes for continuations next time\n\t  options._lst = currIndex;\n\t\n\t  while (stack.length) {\n\t    s = stack.pop();\n\t    s.ul.push(listPad(stack.length));\n\t    // lists have a predictable structure - move pba from listitem to list\n\t    if (s.att === 1 && !s.ul[3][1].substr) {\n\t      merge(s.ul[1], s.ul[3].splice(1, 1)[0]);\n\t    }\n\t  }\n\t\n\t  return s.ul;\n\t}\n\t\n\tmodule.exports = {\n\t  testList: testList,\n\t  parseList: parseList\n\t};\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* definitions list parser */\n\t\n\tvar ribbon = __webpack_require__(5);\n\t\n\tvar _require = __webpack_require__(10),\n\t    addLineNumber = _require.addLineNumber;\n\t\n\tvar reDeflist = /^((?:- (?:[^\\n]\\n?)+?)+:=(?: *\\n[^\\0]+?=:(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- )))))+/;\n\tvar reItem = /^((?:- (?:[^\\n]\\n?)+?)+):=( *\\n[^\\0]+?=:\\s*(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- ))))/;\n\t\n\tfunction testDefList(src) {\n\t  return reDeflist.exec(src);\n\t}\n\t\n\tfunction parseDefList(src, options, charOffset, charPosToLine) {\n\t  if (options.showOriginalLineNumber) {\n\t    var removedSrc = src.match(/^\\s+/);\n\t    if (removedSrc && removedSrc[0]) {\n\t      charOffset += removedSrc[0].length;\n\t    }\n\t  }\n\t  src = ribbon(src.trim());\n\t\n\t  // late loading to get around the lack of non-circular-dependency support in RequireJS\n\t  var parsePhrase = __webpack_require__(9).parsePhrase;\n\t  var parseFlow = __webpack_require__(6).parseFlow;\n\t\n\t  var deflist = ['dl', '\\n'];\n\t  var terms = void 0;\n\t  var def = void 0;\n\t  var m = void 0;\n\t\n\t  while (m = reItem.exec(src)) {\n\t    // add terms\n\t    terms = m[1].split(/(?:^|\\n)\\- /);\n\t    var localCharOffset = terms[0].length;\n\t    terms = terms.slice(1);\n\t    var separators = [];\n\t    if (options.showOriginalLineNumber) {\n\t      separators = m[1].match(/(?:^|\\n)\\- /g).slice(1);\n\t    }\n\t    while (terms.length) {\n\t      var term = terms.shift();\n\t      deflist.push('\\t', ['dt'].concat(addLineNumber({}, options, charPosToLine, charOffset, src.getPos() + localCharOffset), parsePhrase(term.trim(), options)), '\\n');\n\t      if (options.showOriginalLineNumber) {\n\t        localCharOffset += term.length;\n\t        // perhaps no separator at the end of the list\n\t        if (separators.length) {\n\t          localCharOffset += separators.shift().length;\n\t        }\n\t      }\n\t    }\n\t    // add definitions\n\t    def = m[2].trim();\n\t    if (options.showOriginalLineNumber) {\n\t      // rebase local char offset, and add +2 for ':=' between term and definition\n\t      localCharOffset = m[1].length + 2;\n\t\n\t      var _removedSrc = m[2].match(/^\\s+/);\n\t      if (_removedSrc && _removedSrc[0]) {\n\t        localCharOffset += _removedSrc[0].length;\n\t      }\n\t    }\n\t    deflist.push('\\t', ['dd'].concat(addLineNumber({}, options, charPosToLine, charOffset, src.getPos() + localCharOffset), /=:$/.test(def) ? parseFlow(def.slice(0, -2).trim(), options, options.showOriginalLineNumber ? charPosToLine[(charOffset || 0) + localCharOffset + src.getPos()] : 0) : parsePhrase(def, options)), '\\n');\n\t    src.advance(m[0]);\n\t  }\n\t  return deflist;\n\t}\n\t\n\texports.testDefList = testDefList;\n\texports.parseDefList = parseDefList;\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\t/* textile table parser */\n\t\n\tvar re = __webpack_require__(4);\n\tvar merge = __webpack_require__(1);\n\tvar ribbon = __webpack_require__(5);\n\t\n\tvar _require = __webpack_require__(10),\n\t    parseAttr = _require.parseAttr,\n\t    addLineNumber = _require.addLineNumber;\n\t\n\tvar _require2 = __webpack_require__(9),\n\t    parsePhrase = _require2.parsePhrase;\n\t\n\tvar _require3 = __webpack_require__(2),\n\t    reIndent = _require3.reIndent;\n\t\n\tvar _require4 = __webpack_require__(12),\n\t    txattr = _require4.txattr;\n\t\n\tre.pattern.txattr = txattr;\n\t\n\tvar reTable = re.compile(/^((?:table[:txattr:]\\.(?:\\s(.+?))\\s*\\n)?(?:(?:[:txattr:]\\.[^\\n\\S]*)?\\|.*?\\|[^\\n\\S]*(?:\\n|$))+)([^\\n\\S]*\\n)?/, 's');\n\tvar reHead = /^table(_?)([^\\n]*?)\\.(?:[ \\t](.+?))?\\s*\\n/;\n\tvar reRow = re.compile(/^(?:\\|([~\\^\\-][:txattr:])\\.\\s*\\n)?([:txattr:]\\.[^\\n\\S]*)?\\|(.*?)\\|[^\\n\\S]*(\\n|$)/, 's');\n\tvar reCaption = /^\\|=([^\\n+]*)\\n/;\n\tvar reColgroup = /^\\|:([^\\n+]*)\\|[\\r\\t ]*\\n/;\n\tvar reRowgroup = /^\\|([\\^\\-~])([^\\n+]*)\\.[ \\t\\r]*\\n/;\n\t\n\tvar charToTag = {\n\t  '^': 'thead',\n\t  '~': 'tfoot',\n\t  '-': 'tbody'\n\t};\n\t\n\tfunction parseColgroup(src) {\n\t  var colgroup = ['colgroup', {}];\n\t  src.split('|').forEach(function (s, isCol) {\n\t    var col = isCol ? {} : colgroup[1];\n\t    var d = s.trim();\n\t    var m = void 0;\n\t    if (d) {\n\t      if (m = /^\\\\(\\d+)/.exec(d)) {\n\t        col.span = +m[1];\n\t        d = d.slice(m[0].length);\n\t      }\n\t      if (m = parseAttr(d, 'col')) {\n\t        merge(col, m[1]);\n\t        d = d.slice(m[0]);\n\t      }\n\t      if (m = /\\b\\d+\\b/.exec(d)) {\n\t        col.width = +m[0];\n\t      }\n\t    }\n\t    if (isCol) {\n\t      colgroup.push('\\n\\t\\t', ['col', col]);\n\t    }\n\t  });\n\t  return colgroup.concat(['\\n\\t']);\n\t}\n\t\n\tfunction testTable(src) {\n\t  return reTable.exec(src);\n\t}\n\t\n\tfunction parseTable(src, options, charOffset, charPosToLine) {\n\t  if (options.showOriginalLineNumber) {\n\t    var removedSrc = src.match(/^\\s+/);\n\t    if (removedSrc && removedSrc[0]) {\n\t      charOffset += removedSrc[0].length;\n\t    }\n\t  }\n\t  src = ribbon(src.trim());\n\t\n\t  var rowgroups = [];\n\t  var colgroup = void 0;\n\t  var caption = void 0;\n\t  var tAttr = {};\n\t  var tCurr = void 0;\n\t  var row = void 0;\n\t  var inner = void 0;\n\t  var pba = void 0;\n\t  var more = void 0;\n\t  var m = void 0;\n\t  var extended = 0;\n\t\n\t  var setRowGroup = function setRowGroup(type, pba) {\n\t    tCurr = [type, pba || {}];\n\t    rowgroups.push(tCurr);\n\t  };\n\t\n\t  if (m = reHead.exec(src)) {\n\t    // parse and apply table attr\n\t    src.advance(m[0]);\n\t    pba = parseAttr(m[2], 'table');\n\t    if (pba) {\n\t      merge(tAttr, pba[1]);\n\t    }\n\t    if (m[3]) {\n\t      tAttr.summary = m[3];\n\t    }\n\t  }\n\t\n\t  // caption\n\t  if (m = reCaption.exec(src)) {\n\t    caption = ['caption'];\n\t    if (pba = parseAttr(m[1], 'caption')) {\n\t      caption.push(pba[1]);\n\t      m[1] = m[1].slice(pba[0]);\n\t    }\n\t    if (/\\./.test(m[1])) {\n\t      // mandatory \".\"\n\t      caption.push(m[1].slice(1).replace(/\\|\\s*$/, '').trim());\n\t      extended++;\n\t      src.advance(m[0]);\n\t    } else {\n\t      caption = null;\n\t    }\n\t  }\n\t\n\t  do {\n\t    // colgroup\n\t    if (m = reColgroup.exec(src)) {\n\t      colgroup = parseColgroup(m[1]);\n\t      extended++;\n\t    }\n\t    // \"rowgroup\" (tbody, thead, tfoot)\n\t    else if (m = reRowgroup.exec(src)) {\n\t        // PHP allows any amount of these in any order\n\t        // and simply translates them straight through\n\t        // the same is done here.\n\t        var tag = charToTag[m[1]] || 'tbody';\n\t        pba = parseAttr(m[2] + ' ', tag);\n\t        setRowGroup(tag, pba && pba[1]);\n\t        extended++;\n\t      }\n\t      // row\n\t      else if (m = reRow.exec(src)) {\n\t          if (!tCurr) {\n\t            setRowGroup('tbody');\n\t          }\n\t\n\t          row = ['tr'];\n\t\n\t          if (m[2] && (pba = parseAttr(m[2], 'tr'))) {\n\t            // FIXME: requires \"\\.\\s?\" -- else what ?\n\t            row.push(addLineNumber(pba[1], options, charPosToLine, charOffset, src.getPos()));\n\t          } else {\n\t            row.push(addLineNumber({}, options, charPosToLine, charOffset, src.getPos()));\n\t          }\n\t\n\t          tCurr.push('\\n\\t\\t', row);\n\t          inner = ribbon(m[3]);\n\t\n\t          do {\n\t            inner.save();\n\t\n\t            // cell loop\n\t            var th = inner.startsWith('_');\n\t            var cell = [th ? 'th' : 'td'];\n\t            if (th) {\n\t              inner.advance(1);\n\t            }\n\t\n\t            pba = parseAttr(inner, 'td');\n\t            if (pba) {\n\t              inner.advance(pba[0]);\n\t              cell.push(pba[1]); // FIXME: don't do this if next text fails\n\t            }\n\t\n\t            if (pba || th) {\n\t              var p = /^\\.\\s*/.exec(inner);\n\t              if (p) {\n\t                inner.advance(p[0]);\n\t              } else {\n\t                cell = ['td'];\n\t                inner.load();\n\t              }\n\t            }\n\t\n\t            var mx = /^(==.*?==|[^\\|])*/.exec(inner);\n\t            cell = cell.concat(parsePhrase(mx[0], options));\n\t            row.push('\\n\\t\\t\\t', cell);\n\t            more = inner.valueOf().charAt(mx[0].length) === '|';\n\t            inner.advance(mx[0].length + 1);\n\t          } while (more);\n\t\n\t          row.push('\\n\\t\\t');\n\t        }\n\t    //\n\t    if (m) {\n\t      src.advance(m[0]);\n\t    }\n\t  } while (m);\n\t\n\t  // assemble table\n\t  var table = ['table', tAttr];\n\t  if (extended) {\n\t    if (caption) {\n\t      table.push('\\n\\t', caption);\n\t    }\n\t    if (colgroup) {\n\t      table.push('\\n\\t', colgroup);\n\t    }\n\t    rowgroups.forEach(function (tbody) {\n\t      table.push('\\n\\t', tbody.concat(['\\n\\t']));\n\t    });\n\t  } else {\n\t    table = table.concat(reIndent(rowgroups[0].slice(2), -1));\n\t  }\n\t\n\t  table.push('\\n');\n\t  return table;\n\t}\n\t\n\tmodule.exports = {\n\t  parseColgroup: parseColgroup,\n\t  parseTable: parseTable,\n\t  testTable: testTable\n\t};\n\n/***/ })\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// textile.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap d3a0f4bd1c1a6085132c","/*\n** Textile parser for JavaScript\n**\n** Copyright (c) 2012 Borgar Þorsteinsson (MIT License).\n**\n*/\n\nconst merge = require( './merge' );\nconst { toHTML } = require( './jsonml' );\nconst { parseFlow } = require( './textile/flow' );\nconst { parseHtml } = require( './html' );\n\nfunction textile ( txt, opt ) {\n  // get a throw-away copy of options\n  opt = merge( merge({}, textile.defaults ), opt || {});\n  // run the converter\n  return parseFlow( txt, opt, opt.lineOffset ).map( toHTML ).join( '' );\n};\nmodule.exports = textile;\n\n// options\ntextile.defaults = {\n  // single-line linebreaks are converted to <br> by default\n  'breaks': true,\n  // by default, don't map the elements of HTML output, with the line numbers of input text\n  'showOriginalLineNumber': false,\n  // line number offset of the first char of input text, for showOriginalLineNumber option\n  'lineOffset': 0,\n  // by default, don't set a special CSS class name to each HTML element mapped to an original line number\n  'cssClassOriginalLineNumber': ''\n};\ntextile.setOptions = textile.setoptions = function ( opt ) {\n  merge( textile.defaults, opt );\n  return this;\n};\n\ntextile.parse = textile.convert = textile;\ntextile.html_parser = parseHtml;\n\ntextile.jsonml = function ( txt, opt ) {\n  // get a throw-away copy of options\n  opt = merge( merge({}, textile.defaults ), opt || {});\n  // parse and return tree\n  return [ 'html' ].concat( parseFlow( txt, opt, opt.lineOffset ) );\n};\ntextile.serialize = toHTML;\n\n\n\n// WEBPACK FOOTER //\n// ./src/index.js","// merge object b properties into object a\nmodule.exports = function merge ( a, b ) {\n  if ( b ) {\n    for ( const k in b ) {\n      a[ k ] = b[ k ];\n    }\n  }\n  return a;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/merge.js","/*\n** JSONML helper methods - http://www.jsonml.org/\n**\n** This provides the `JSONML` object, which contains helper\n** methods for rendering JSONML to HTML.\n**\n** Note that the tag ! is taken to mean comment, this is however\n** not specified in the JSONML spec.\n*/\n\nconst singletons = require( './html' ).singletons;\n\n// drop or add tab levels to JsonML tree\nfunction reIndent ( ml, shiftBy ) {\n  // a bit obsessive, but there we are...\n  if ( !shiftBy ) {\n    return ml;\n  }\n  return ml.map( function ( s ) {\n    if ( /^\\n\\t+/.test( s ) ) {\n      if ( shiftBy < 0 ) {\n        s = s.slice( 0, shiftBy );\n      }\n      else {\n        for ( let i = 0; i < shiftBy; i++ ) {\n          s += '\\t';\n        }\n      }\n    }\n    else if ( Array.isArray( s ) ) {\n      return reIndent( s, shiftBy );\n    }\n    return s;\n  });\n}\n\nfunction escape ( text, escapeQuotes ) {\n  return text.replace( /&(?!(#\\d{2,}|#x[\\da-fA-F]{2,}|[a-zA-Z][a-zA-Z1-4]{1,6});)/g, '&amp;' )\n             .replace( /</g, '&lt;' )\n             .replace( />/g, '&gt;' )\n             .replace( /\"/g, escapeQuotes ? '&quot;' : '\"' )\n             .replace( /'/g, escapeQuotes ? '&#39;' : \"'\" );\n}\n\nfunction toHTML ( jsonml ) {\n  jsonml = jsonml.concat();\n\n  // basic case\n  if ( typeof jsonml === 'string' ) {\n    return escape( jsonml );\n  }\n\n  const tag = jsonml.shift();\n  let attributes = {};\n  let tagAttrs = '';\n  const content = [];\n\n  if ( jsonml.length && typeof jsonml[0] === 'object' && !Array.isArray( jsonml[0] ) ) {\n    attributes = jsonml.shift();\n  }\n\n  while ( jsonml.length ) {\n    content.push( toHTML( jsonml.shift() ) );\n  }\n\n  for ( const a in attributes ) {\n    tagAttrs += ( attributes[a] == null )\n            ? ` ${ a }`\n            : ` ${ a }=\"${ escape( String( attributes[a] ), true ) }\"`;\n  }\n\n  // be careful about adding whitespace here for inline elements\n  if ( tag === '!' ) {\n    return `<!--${ content.join( '' ) }-->`;\n  }\n  else if ( tag in singletons || ( tag.indexOf( ':' ) > -1 && !content.length ) ) {\n    return `<${ tag }${ tagAttrs } />`;\n  }\n  else {\n    return `<${ tag }${ tagAttrs }>${ content.join( '' ) }</${ tag }>`;\n  }\n}\n\nmodule.exports = {\n  reIndent: reIndent,\n  toHTML: toHTML,\n  escape: escape\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/jsonml.js","const re = require( './re' );\nconst ribbon = require( './ribbon' );\n\nre.pattern.html_id = '[a-zA-Z][a-zA-Z\\\\d:]*';\nre.pattern.html_attr = '(?:\"[^\"]+\"|\\'[^\\']+\\'|[^>\\\\s]+)';\n\nconst reAttr = re.compile( /^\\s*([^=\\s]+)(?:\\s*=\\s*(\"[^\"]+\"|'[^']+'|[^>\\s]+))?/ );\nconst reComment = re.compile( /^<!--(.+?)-->/, 's' );\nconst reEndTag = re.compile( /^<\\/([:html_id:])([^>]*)>/ );\nconst reTag = re.compile( /^<([:html_id:])((?:\\s[^=\\s\\/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>/ );\nconst reHtmlTagBlock = re.compile( /^\\s*<([:html_id:](?::[a-zA-Z\\d]+)*)((?:\\s[^=\\s\\/]+(?:\\s*=\\s*[:html_attr:])?)+)?\\s*(\\/?)>/ );\n\nconst singletons = {\n  area: 1,\n  base: 1,\n  br: 1,\n  col: 1,\n  embed: 1,\n  hr: 1,\n  img: 1,\n  input: 1,\n  link: 1,\n  meta: 1,\n  option: 1,\n  param: 1,\n  wbr: 1\n};\n\nfunction allowAll () {\n  return true;\n}\n\nfunction testComment ( src ) {\n  return reComment.exec( src );\n}\n\nfunction testOpenTagBlock ( src ) {\n  return reHtmlTagBlock.exec( src );\n}\n\nfunction testOpenTag ( src ) {\n  return reTag.exec( src );\n}\n\nfunction testCloseTag ( src ) {\n  return reEndTag.exec( src );\n}\n\nfunction parseHtmlAttr ( attrSrc ) {\n  // parse ATTR and add to element\n  const attr = {};\n  let m;\n  while ( ( m = reAttr.exec( attrSrc ) ) ) {\n    attr[ m[1] ] = ( typeof m[2] === 'string' ) ? m[2].replace( /^([\"'])(.*)\\1$/, '$2' ) : null;\n    attrSrc = attrSrc.slice( m[0].length );\n  }\n  return attr;\n}\n\nconst OPEN = 'OPEN';\nconst CLOSE = 'CLOSE';\nconst SINGLE = 'SINGLE';\nconst TEXT = 'TEXT';\nconst COMMENT = 'COMMENT';\nconst WS = 'WS';\n\nfunction tokenize ( src, whitelistTags, lazy ) {\n  const tokens = [];\n  let textMode = false;\n  let oktag = whitelistTags ? ( tag ) => tag in whitelistTags : allowAll;\n  const oktag_ = oktag;\n  const nesting = {};\n  let nestCount = 0;\n  let m;\n\n  src = ribbon( String( src ) );\n\n  do {\n    // comment\n    if ( ( m = testComment( src ) ) && oktag( '!' ) ) {\n      tokens.push({\n        type: COMMENT,\n        data: m[1],\n        pos: src.index(),\n        src: m[0]\n      });\n      src.advance( m[0] );\n    }\n\n    // end tag\n    else if ( ( m = testCloseTag( src ) ) && oktag( m[1] ) ) {\n      const token = {\n        type: CLOSE,\n        tag: m[1],\n        pos: src.index(),\n        src: m[0]\n      };\n      src.advance( m[0] );\n      tokens.push( token );\n      nesting[token.tag]--;\n      nestCount--;\n      // console.log( '/' + token.tag, nestCount, nesting );\n      if ( lazy && (\n          !nestCount ||\n          !nesting[token.tag] < 0 ||\n          isNaN( nesting[token.tag] )\n        ) ) {\n        return tokens;\n      }\n      // if parse is in text mode then that ends here\n      if ( textMode ) {\n        textMode = null;\n        oktag = oktag_;\n      }\n    }\n\n    // open/void tag\n    else if ( ( m = testOpenTag( src ) ) && oktag( m[1] ) ) {\n      const token = {\n        type: m[3] || m[1] in singletons ? SINGLE : OPEN,\n        tag: m[1],\n        pos: src.index(),\n        src: m[0]\n      };\n      if ( m[2] ) {\n        token.attr = parseHtmlAttr( m[2] );\n      }\n      // some elements can move parser into \"text\" mode\n      if ( m[1] === 'script' || m[1] === 'code' || m[1] === 'style' ) {\n        textMode = token.tag;\n        oktag = tag => tag === textMode;\n      }\n      if ( token.type === OPEN ) {\n        nestCount++;\n        nesting[token.tag] = ( nesting[token.tag] || 0 ) + 1;\n        // console.log( token.tag, nestCount, nesting );\n      }\n      tokens.push( token );\n      src.advance( m[0] );\n    }\n\n    // text content\n    else {\n      // no match, move by all \"uninteresting\" chars\n      m = /([^<]+|[^\\0])/.exec( src );\n      if ( m ) {\n        tokens.push({\n          type: TEXT,\n          data: m[0],\n          pos: src.index(),\n          src: m[0]\n        });\n      }\n      src.advance( m ? m[0].length || 1 : 1 );\n    }\n  }\n  while ( src.valueOf() );\n\n  return tokens;\n}\n\n// This \"indesciminately\" parses HTML text into a list of JSON-ML element\n// No steps are taken however to prevent things like <table><p><td> - user can still create nonsensical but \"well-formed\" markup\nfunction parse ( tokens, lazy ) {\n  const root = [];\n  const stack = [];\n  let curr = root;\n  let token;\n  for ( let i = 0; i < tokens.length; i++ ) {\n    token = tokens[i];\n    if ( token.type === COMMENT ) {\n      curr.push( [ '!', token.data ] );\n    }\n    else if ( token.type === TEXT || token.type === WS ) {\n      curr.push( token.data );\n    }\n    else if ( token.type === SINGLE ) {\n      curr.push( token.attr ? [ token.tag, token.attr ] : [ token.tag ] );\n    }\n    else if ( token.type === OPEN ) {\n      // TODO: some things auto close other things: <td>, <li>, <p>, <table>\n      // https://html.spec.whatwg.org/multipage/syntax.html#syntax-tag-omission\n      const elm = token.attr ? [ token.tag, token.attr ] : [ token.tag ];\n      curr.push( elm );\n      stack.push( elm );\n      curr = elm;\n    }\n    else if ( token.type === CLOSE ) {\n      if ( stack.length ) {\n        for ( let i = stack.length - 1; i >= 0; i-- ) {\n          const head = stack[i];\n          if ( head[0] === token.tag ) {\n            stack.splice( i );\n            curr = stack[stack.length - 1] || root;\n            break;\n          }\n        }\n      }\n      if ( !stack.length && lazy ) {\n        root.sourceLength = token.pos + token.src.length;\n        return root;\n      }\n    }\n  }\n  root.sourceLength = token ? token.pos + token.src.length : 0;\n  return root;\n}\n\nmodule.exports = {\n  singletons: singletons,\n  tokenize: tokenize,\n  parseHtml: parse,\n  parseHtmlAttr: parseHtmlAttr,\n  testCloseTag: testCloseTag,\n  testOpenTagBlock: testOpenTagBlock,\n  testOpenTag: testOpenTag,\n  testComment: testComment\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/html.js","/*\n** Regular Expression helper methods\n**\n** This provides the `re` object, which contains several helper\n** methods for working with big regular expressions (soup).\n**\n*/\n\nconst _cache = {};\n\nconst re = module.exports = {\n\n  pattern: {\n    'punct': '[!-/:-@\\\\[\\\\\\\\\\\\]-`{-~]',\n    'space': '\\\\s'\n  },\n\n  escape: function ( src ) {\n    return src.replace( /[\\-\\[\\]\\{\\}\\(\\)\\*\\+\\?\\.,\\\\\\^\\$\\|#\\s]/g, '\\\\$&' );\n  },\n\n  collapse: function ( src ) {\n    return src.replace( /(?:#.*?(?:\\n|$))/g, '' )\n              .replace( /\\s+/g, '' );\n  },\n\n  expandPatterns: function ( src ) {\n    // TODO: provide escape for patterns: \\[:pattern:] ?\n    return src.replace( /\\[:\\s*(\\w+)\\s*:\\]/g, function ( m, k ) {\n      const ex = re.pattern[k];\n      if ( ex ) {\n        return re.expandPatterns( ex );\n      }\n      else {\n        throw new Error( 'Pattern ' + m + ' not found in ' + src );\n      }\n    });\n  },\n\n  isRegExp: function ( r ) {\n    return Object.prototype.toString.call( r ) === '[object RegExp]';\n  },\n\n  compile: function ( src, flags ) {\n    if ( re.isRegExp( src ) ) {\n      if ( arguments.length === 1 ) { // no flags arg provided, use the RegExp one\n        flags = ( src.global ? 'g' : '' ) +\n                ( src.ignoreCase ? 'i' : '' ) +\n                ( src.multiline ? 'm' : '' );\n      }\n      src = src.source;\n    }\n    // don't do the same thing twice\n    const ckey = src + ( flags || '' );\n    if ( ckey in _cache ) {\n      return _cache[ ckey ];\n    }\n    // allow classes\n    let rx = re.expandPatterns( src );\n    // allow verbose expressions\n    if ( flags && /x/.test( flags ) ) {\n      rx = re.collapse( rx );\n    }\n    // allow dotall expressions\n    if ( flags && /s/.test( flags ) ) {\n      rx = rx.replace( /([^\\\\])\\./g, '$1[^\\\\0]' );\n    }\n    // TODO: test if MSIE and add replace \\s with [\\s\\u00a0] if it is?\n    // clean flags and output new regexp\n    flags = ( flags || '' ).replace( /[^gim]/g, '' );\n    return ( _cache[ ckey ] = new RegExp( rx, flags ) );\n  }\n\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/re.js","module.exports = function ribbon ( feed ) {\n  const org = String( feed );\n  let slot;\n  let pos = 0;\n  const self = {\n\n    index: () => {\n      return pos;\n    },\n\n    save: () => {\n      slot = pos;\n      return self;\n    },\n\n    getSlot: () => {\n      return slot || 0;\n    },\n\n    getPos: () => {\n      return pos || 0;\n    },\n\n    load: () => {\n      pos = slot;\n      feed = org.slice( pos );\n      return self;\n    },\n\n    advance: n => {\n      pos += ( typeof n === 'string' ) ? n.length : n;\n      feed = org.slice( pos );\n      return feed;\n    },\n\n    skipWS: () => {\n      const ws = /^\\s+/.exec( feed );\n      if ( ws ) {\n        pos += ws[0].length;\n        feed = org.slice( pos );\n        return ws[0];\n      }\n      return '';\n    },\n\n    lookbehind: nchars => {\n      nchars = nchars == null ? 1 : nchars;\n      return org.slice( pos - nchars, pos );\n    },\n\n    startsWith: s => {\n      return feed.substring( 0, s.length ) === s;\n    },\n\n    slice: ( a, b ) => {\n      return b != null ? feed.slice( a, b ) : feed.slice( a );\n    },\n\n    valueOf: () => {\n      return feed;\n    },\n\n    toString: () => {\n      return feed;\n    }\n\n  };\n\n  return self;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/ribbon.js","/*\n** textile flow content parser\n*/\nconst builder = require( '../builder' );\nconst ribbon = require( '../ribbon' );\nconst re = require( '../re' );\nconst fixLinks = require( '../fixlinks' );\n\nconst { parseHtml, tokenize, parseHtmlAttr, singletons, testComment, testOpenTagBlock } = require( '../html' );\n\nconst { parsePhrase } = require( './phrase' );\nconst { copyAttr, parseAttr, addLineNumber } = require( './attr' );\nconst { testList, parseList } = require( './list' );\nconst { testDefList, parseDefList } = require( './deflist' );\nconst { testTable, parseTable } = require( './table' );\n\nconst { txblocks, txlisthd, txattr } = require( './re_ext' );\nre.pattern.txblocks = txblocks;\nre.pattern.txlisthd = txlisthd;\nre.pattern.txattr = txattr;\n\n// HTML tags allowed in the document (root) level that trigger HTML parsing\nconst allowedBlocktags = {\n  'p': 0,\n  'hr': 0,\n  'ul': 1,\n  'ol': 0,\n  'li': 0,\n  'div': 1,\n  'pre': 0,\n  'object': 1,\n  'script': 0,\n  'noscript': 0,\n  'blockquote': 1,\n  'notextile': 1\n};\n\nconst reBlock = re.compile( /^([:txblocks:])/ );\nconst reBlockNormal = re.compile( /^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n(?:\\s*\\n|$)+)/, 's' );\nconst reBlockExtended = re.compile( /^(.*?)($|\\r?\\n(?=[:txlisthd:])|\\r?\\n+(?=[:txblocks:][:txattr:]\\.))/, 's' );\nconst reBlockNormalPre = re.compile( /^(.*?)($|\\r?\\n(?:\\s*\\n|$)+)/, 's' );\nconst reBlockExtendedPre = re.compile( /^(.*?)($|\\r?\\n+(?=[:txblocks:][:txattr:]\\.))/, 's' );\n\nconst reRuler = /^(\\-\\-\\-+|\\*\\*\\*+|___+)(\\r?\\n\\s+|$)/;\nconst reLinkRef = re.compile( /^\\[([^\\]]+)\\]((?:https?:\\/\\/|\\/)\\S+)(?:\\s*\\n|$)/ );\nconst reFootnoteDef = /^fn\\d+$/;\n\nconst reCleanBegin = /^( *\\r?\\n)+/;\n\nconst hasOwn = Object.prototype.hasOwnProperty;\nfunction extend ( target, ...args ) {\n  for ( let i = 1; i < args.length; i++ ) {\n    const src = args[i];\n    if ( src != null ) {\n      for ( const nextKey in src ) {\n        if ( hasOwn.call( src, nextKey ) ) {\n          target[nextKey] = src[nextKey];\n        }\n      }\n    }\n  }\n  return target;\n}\n\n\nfunction paragraph ( s, tag, pba, linebreak, options ) {\n  tag = tag || 'p';\n  let out = [];\n  s.split( /(?:\\r?\\n){2,}/ ).forEach( function ( bit, i ) {\n    if ( tag === 'p' && /^\\s/.test( bit ) ) {\n      // no-paragraphs\n      bit = bit.replace( /\\r?\\n[\\t ]/g, ' ' ).trim();\n      out = out.concat( parsePhrase( bit, options ) );\n    }\n    else {\n      if ( linebreak && i ) { out.push( linebreak ); }\n      out.push( pba ? [ tag, pba ].concat( parsePhrase( bit, options ) )\n                    : [ tag ].concat( parsePhrase( bit, options ) ) );\n    }\n  });\n  return out;\n};\n\nfunction computeCharOffset ( src, options, lineOffset ) {\n  if ( options.showOriginalLineNumber ) {\n    lineOffset = lineOffset || 0;\n\n    const removedSrc = src.match( reCleanBegin );\n    if ( removedSrc && removedSrc[0] ) {\n      lineOffset += ( removedSrc[0].match( /\\n/g ) || [] ).length;\n    }\n    return lineOffset;\n  }\n  else {\n    return 0;\n  }\n}\n\nfunction storeCharPosToLine ( src, options, charOffset ) {\n  // FIXME: don't store all chr ?\n  if ( options.showOriginalLineNumber ) {\n    const charPosToLine = [];\n    const realSrc = src.toString();\n    for ( const i in realSrc ) {\n      charPosToLine[ i ] = charOffset;\n      if ( realSrc[ i ] === '\\n' ) {\n        charOffset++;\n      }\n    }\n    return charPosToLine;\n  }\n  else {\n    return void 0;\n  }\n}\n\nfunction parseFlow ( src, options, lineOffset ) {\n  const list = builder();\n\n  let linkRefs;\n  let m;\n\n  // keep as local variable, for nested calls (->block HTML)\n  const charLineOffset = computeCharOffset( src, options, lineOffset );\n\n  src = ribbon( src.replace( reCleanBegin, '' ) );\n\n  // keep as local variable, for nested calls (->block HTML)\n  const charPosToLine = storeCharPosToLine( src, options, charLineOffset );\n\n  // loop\n  while ( src.valueOf() ) {\n    src.save();\n\n    // link_ref -- this goes first because it shouldn't trigger a linebreak\n    if ( ( m = reLinkRef.exec( src ) ) ) {\n      if ( !linkRefs ) { linkRefs = {}; }\n      src.advance( m[0] );\n      linkRefs[m[1]] = m[2];\n      continue;\n    }\n\n    // add linebreak\n    list.linebreak();\n\n    // named block\n    if ( ( m = reBlock.exec( src ) ) ) {\n      src.advance( m[0] );\n      const blockType = m[0];\n      let pba = parseAttr( src, blockType );\n\n      if ( pba ) {\n        src.advance( pba[0] );\n        pba = pba[1];\n      }\n      pba = addLineNumber( pba, options, charPosToLine, 0, src.getSlot() );\n      if ( ( m = /^\\.(\\.?)(?:\\s|(?=:))/.exec( src ) ) ) {\n        // FIXME: this whole copyAttr seems rather strange?\n        // slurp rest of block\n        const extended = !!m[1];\n        let reBlockGlob = ( extended ? reBlockExtended : reBlockNormal );\n        if ( blockType === 'bc' || blockType === 'pre' ) {\n          reBlockGlob = ( extended ? reBlockExtendedPre : reBlockNormalPre );\n        }\n        m = reBlockGlob.exec( src.advance( m[0] ) );\n        src.advance( m[0] );\n        // bq | bc | notextile | pre | h# | fn# | p | ###\n        if ( blockType === 'bq' ) {\n          let inner = m[1];\n          if ( ( m = /^:(\\S+)\\s+/.exec( inner ) ) ) {\n            if ( !pba ) { pba = {}; }\n            pba.cite = m[1];\n            inner = inner.slice( m[0].length );\n          }\n          // RedCloth adds all attr to both: this is bad because it produces duplicate IDs\n          const par = paragraph( inner, 'p', copyAttr( pba, { 'cite': 1, 'id': 1 }), '\\n', options );\n          list.add( [ 'blockquote', pba, '\\n' ].concat( par ).concat( [ '\\n' ] ) );\n        }\n        else if ( blockType === 'bc' ) {\n          const subPba = ( pba ) ? copyAttr( pba, { 'id': 1 }) : null;\n          list.add( [ 'pre', pba, ( subPba ? [ 'code', subPba, m[1] ] : [ 'code', m[1] ] ) ] );\n        }\n        else if ( blockType === 'notextile' ) {\n          list.merge( parseHtml( tokenize( m[1] ) ) );\n        }\n        else if ( blockType === '###' ) {\n          // ignore the insides\n        }\n        else if ( blockType === 'pre' ) {\n          // I disagree with RedCloth, but agree with PHP here:\n          // \"pre(foo#bar).. line1\\n\\nline2\" prevents multiline preformat blocks\n          // ...which seems like the whole point of having an extended pre block?\n          list.add( [ 'pre', pba, m[1] ] );\n        }\n        else if ( reFootnoteDef.test( blockType ) ) { // footnote\n          // Need to be careful: RedCloth fails \"fn1(foo#m). footnote\" -- it confuses the ID\n          const fnid = blockType.replace( /\\D+/g, '' );\n          if ( !pba ) { pba = {}; }\n          pba.class = ( pba['class'] ? pba['class'] + ' ' : '' ) + 'footnote';\n          pba.id = 'fn' + fnid;\n          list.add( [ 'p', pba, [ 'a', { 'href': '#fnr' + fnid }, [ 'sup', fnid ] ], ' ' ]\n                      .concat( parsePhrase( m[1], options ) ) );\n        }\n        else { // heading | paragraph\n          list.merge( paragraph( m[1], blockType, pba, '\\n', options ) );\n        }\n        continue;\n      }\n      else {\n        src.load();\n      }\n    }\n\n    // HTML comment\n    if ( ( m = testComment( src ) ) ) {\n      src.advance( m[0] + ( /(?:\\s*\\n+)+/.exec( src ) || [] )[0] );\n      list.add( [ '!', m[1] ] );\n      continue;\n    }\n\n    // block HTML\n    if ( ( m = testOpenTagBlock( src ) ) ) {\n      const tag = m[1];\n\n      // Is block tag? ...\n      if ( tag in allowedBlocktags ) {\n        if ( m[3] || tag in singletons ) { // single?\n          src.advance( m[0] );\n          if ( /^\\s*(\\n|$)/.test( src ) ) {\n            const elm = [ tag ];\n            if ( m[2] ) { elm.push( parseHtmlAttr( m[2] ) ); }\n            list.add( elm );\n            src.skipWS();\n            continue;\n          }\n        }\n        else if ( tag === 'pre' ) {\n          const t = tokenize( src, { 'pre': 1, 'code': 1 }, tag );\n          const p = parseHtml( t, true );\n          src.load().advance( p.sourceLength );\n          if ( /^\\s*(\\n|$)/.test( src ) ) {\n            list.merge( p );\n            src.skipWS(); // skip tailing whitespace\n            continue;\n          }\n        }\n        else if ( tag === 'notextile' ) {\n          // merge all child elements\n          const t = tokenize( src, null, tag );\n          let s = 1; // start after open tag\n          while ( /^\\s+$/.test( t[s].src ) ) {\n            s++; // skip whitespace\n          }\n          const p = parseHtml( t.slice( s, -1 ), true );\n          const x = t.pop();\n          src.load().advance( x.pos + x.src.length );\n          if ( /^\\s*(\\n|$)/.test( src ) ) {\n            list.merge( p );\n            src.skipWS(); // skip tailing whitespace\n            continue;\n          }\n        }\n        else {\n          src.skipWS();\n          const t = tokenize( src, null, tag );\n          const x = t.pop(); // this should be the end tag\n          let s = 1; // start after open tag\n          while ( t[s] && /^[\\n\\r]+$/.test( t[s].src ) ) {\n            s++; // skip whitespace\n          }\n          if ( x.tag === tag ) {\n            // inner can be empty\n            const inner = ( t.length > 1 ) ? src.slice( t[s].pos, x.pos ) : '';\n            src.advance( x.pos + x.src.length );\n            if ( /^\\s*(\\n|$)/.test( src ) ) {\n              let elm = [ tag ];\n              if ( m[2] ) { elm.push( parseHtmlAttr( m[2] ) ); }\n              if ( tag === 'script' || tag === 'style' ) {\n                elm.push( inner );\n              }\n              else {\n                const innerHTML = inner.replace( /^\\n+/, '' ).replace( /\\s*$/, '' );\n                const isBlock = /\\n\\r?\\n/.test( innerHTML ) || tag === 'ol' || tag === 'ul';\n                const innerElm = isBlock\n                      ? parseFlow( innerHTML, options )\n                      : parsePhrase( innerHTML, extend({}, options, { breaks: false }) );\n                if ( isBlock || /^\\n/.test( inner ) ) {\n                  elm.push( '\\n' );\n                }\n                if ( isBlock || /\\s$/.test( inner ) ) {\n                  innerElm.push( '\\n' );\n                }\n                elm = elm.concat( innerElm );\n              }\n\n              list.add( elm );\n              src.skipWS(); // skip tailing whitespace\n              continue;\n            }\n          }\n        }\n      }\n      src.load();\n    }\n\n    // ruler\n    if ( ( m = reRuler.exec( src ) ) ) {\n      src.advance( m[0] );\n      list.add( [ 'hr' ] );\n      continue;\n    }\n\n    // list\n    if ( ( m = testList( src ) ) ) {\n      src.advance( m[0] );\n      list.add( parseList( m[0], options, src.getSlot(), charPosToLine ) );\n      continue;\n    }\n\n    // definition list\n    if ( ( m = testDefList( src ) ) ) {\n      src.advance( m[0] );\n      list.add( parseDefList( m[0], options, src.getSlot(), charPosToLine ) );\n      continue;\n    }\n\n    // table\n    if ( ( m = testTable( src ) ) ) {\n      src.advance( m[0] );\n      list.add( parseTable( m[1], options, src.getSlot(), charPosToLine ) );\n      continue;\n    }\n\n    // paragraph\n    m = reBlockNormal.exec( src );\n    list.merge( paragraph( m[1], 'p', addLineNumber({}, options, charPosToLine, 0, src.getSlot() ), '\\n', options ) );\n    src.advance( m[0] );\n  }\n\n  return linkRefs ? fixLinks( list.get(), linkRefs ) : list.get();\n}\n\nexports.parseFlow = parseFlow;\n\n\n\n// WEBPACK FOOTER //\n// ./src/textile/flow.js","module.exports = function builder ( initArr ) {\n  const arr = Array.isArray( initArr ) ? initArr : [];\n\n  return {\n    add: function ( node ) {\n      if ( typeof node === 'string' &&\n           typeof arr[ arr.length - 1 ] === 'string' ) {\n        // join if possible\n        arr[ arr.length - 1 ] += node;\n      }\n      else if ( Array.isArray( node ) ) {\n        arr.push( node.filter( s => s !== undefined ) );\n      }\n      else if ( node ) {\n        arr.push( node );\n      }\n      return this;\n    },\n\n    merge: function ( arr ) {\n      for ( let i = 0, l = arr.length; i < l; i++ ) {\n        this.add( arr[i] );\n      }\n      return this;\n    },\n\n    linebreak: function () {\n      if ( arr.length ) {\n        this.add( '\\n' );\n      }\n    },\n\n    get: function () {\n      return arr;\n    }\n  };\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/builder.js","// recurse the tree and swap out any \"href\" attributes\n// this uses the context as the replace dictionary so it can be fed to Array#map\nmodule.exports = function fixLinks ( ml, dict ) {\n  if ( Array.isArray( ml ) ) {\n    if ( ml[0] === 'a' ) { // found a link\n      const attr = ml[1];\n      if ( typeof attr === 'object' && 'href' in attr && attr.href in dict ) {\n        attr.href = dict[attr.href];\n      }\n    }\n    for ( let i = 0, l = ml.length; i < l; i++ ) {\n      if ( Array.isArray( ml[i] ) ) {\n        fixLinks( ml[i], dict );\n      }\n    }\n  }\n  return ml;\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/fixlinks.js","/* textile inline parser */\n\nconst ribbon = require( '../ribbon' );\nconst builder = require( '../builder' );\nconst re = require( '../re' );\n\nconst { parseAttr } = require( './attr' );\nconst { parseGlyph } = require( './glyph' );\nconst { parseHtml, parseHtmlAttr, tokenize, singletons, testComment, testOpenTag } = require( '../html' );\n\nconst { ucaps, txattr, txcite } = require( './re_ext' );\nre.pattern.txattr = txattr;\nre.pattern.txcite = txcite;\nre.pattern.ucaps = ucaps;\n\nconst phraseConvert = {\n  '*': 'strong',\n  '**': 'b',\n  '??': 'cite',\n  '_': 'em',\n  '__': 'i',\n  '-': 'del',\n  '%': 'span',\n  '+': 'ins',\n  '~': 'sub',\n  '^': 'sup',\n  '@': 'code'\n};\n\nconst rePhrase = /^([\\[\\{]?)(__?|\\*\\*?|\\?\\?|[\\-\\+\\^~@%])/;\nconst reImage = re.compile( /^!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^\\.\\/]))?)([^!\\s]+?) ?(?:\\(((?:[^\\(\\)]|\\([^\\(\\)]+\\))+)\\))?!(?::([^\\s]+?(?=[!-\\.:-@\\[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?/ );\nconst reImageFenced = re.compile( /^\\[!(?!\\s)([:txattr:](?:\\.[^\\n\\S]|\\.(?:[^\\.\\/]))?)([^!\\s]+?) ?(?:\\(((?:[^\\(\\)]|\\([^\\(\\)]+\\))+)\\))?!(?::([^\\s]+?(?=[!-\\.:-@\\[\\\\\\]-`{-~](?:$|\\s)|\\s|$)))?\\]/ );\n// NB: there is an exception in here to prevent matching \"TM)\"\nconst reCaps = re.compile( /^((?!TM\\)|tm\\))[[:ucaps:]](?:[[:ucaps:]\\d]{1,}(?=\\()|[[:ucaps:]\\d]{2,}))(?:\\((.*?)\\))?(?=\\W|$)/ );\nconst reLink = re.compile( /^\"(?!\\s)((?:[^\"]|\"(?![\\s:])[^\\n\"]+\"(?!:))+)\"[:txcite:]/ );\nconst reLinkFenced = /^\\[\"([^\\n]+?)\":((?:\\[[a-z0-9]*\\]|[^\\]])+)\\]/;\nconst reLinkTitle = /\\s*\\(((?:\\([^\\(\\)]*\\)|[^\\(\\)])+)\\)$/;\nconst reFootnote = /^\\[(\\d+)(!?)\\]/;\n\nfunction parsePhrase ( src, options ) {\n  src = ribbon( src );\n  const list = builder();\n  let m;\n  let pba;\n\n  // loop\n  do {\n    src.save();\n\n    // linebreak -- having this first keeps it from messing to much with other phrases\n    if ( src.startsWith( '\\r\\n' ) ) {\n      src.advance( 1 ); // skip cartridge returns\n    }\n    if ( src.startsWith( '\\n' ) ) {\n      src.advance( 1 );\n      if ( src.startsWith( ' ' ) ) {\n        src.advance( 1 );\n      }\n      else if ( options.breaks ) {\n        list.add( [ 'br' ] );\n      }\n      list.add( '\\n' );\n      continue;\n    }\n\n    // inline notextile\n    if ( ( m = /^==(.*?)==/.exec( src ) ) ) {\n      src.advance( m[0] );\n      list.add( m[1] );\n      continue;\n    }\n\n    // lookbehind => /([\\s>.,\"'?!;:])$/\n    const behind = src.lookbehind( 1 );\n    const boundary = !behind || /^[\\s>.,\"'?!;:()]$/.test( behind );\n    // FIXME: need to test right boundary for phrases as well\n    if ( ( m = rePhrase.exec( src ) ) && ( boundary || m[1] ) ) {\n      src.advance( m[0] );\n      const tok = m[2];\n      const fence = m[1];\n      const phraseType = phraseConvert[tok];\n      const code = phraseType === 'code';\n\n      if ( ( pba = !code && parseAttr( src, phraseType, tok ) ) ) {\n        src.advance( pba[0] );\n        pba = pba[1];\n      }\n      // FIXME: if we can't match the fence on the end, we should output fence-prefix as normal text\n      // seek end\n      let mMid;\n      let mEnd;\n      if ( fence === '[' ) {\n        mMid = '^(.*?)';\n        mEnd = '(?:])';\n      }\n      else if ( fence === '{' ) {\n        mMid = '^(.*?)';\n        mEnd = '(?:})';\n      }\n      else {\n        const t1 = re.escape( tok.charAt( 0 ) );\n        mMid = ( code ) ? '^(\\\\S+|\\\\S+.*?\\\\S)'\n                        : `^([^\\\\s${ t1 }]+|[^\\\\s${ t1 }].*?\\\\S(${ t1 }*))`;\n        mEnd = '(?=$|[\\\\s.,\"\\'!?;:()«»„“”‚‘’])';\n      }\n      const rx = re.compile( `${ mMid }(${ re.escape( tok ) })${ mEnd }` );\n      if ( ( m = rx.exec( src ) ) && m[1] ) {\n        src.advance( m[0] );\n        if ( code ) {\n          list.add( [ phraseType, m[1] ] );\n        }\n        else {\n          list.add( [ phraseType, pba ].concat( parsePhrase( m[1], options ) ) );\n        }\n        continue;\n      }\n      // else\n      src.load();\n    }\n\n    // image\n    if ( ( m = reImage.exec( src ) ) || ( m = reImageFenced.exec( src ) ) ) {\n      src.advance( m[0] );\n\n      pba = m[1] && parseAttr( m[1], 'img' );\n      const attr = pba ? pba[1] : { 'src': '' };\n      let img = [ 'img', attr ];\n      attr.src = m[2];\n      attr.alt = m[3] ? ( attr.title = m[3] ) : '';\n\n      if ( m[4] ) { // +cite causes image to be wraped with a link (or link_ref)?\n        // TODO: support link_ref for image cite\n        img = [ 'a', { 'href': m[4] }, img ];\n      }\n      list.add( img );\n      continue;\n    }\n\n    // html comment\n    if ( ( m = testComment( src ) ) ) {\n      src.advance( m[0] );\n      list.add( [ '!', m[1] ] );\n      continue;\n    }\n    // html tag\n    // TODO: this seems to have a lot of overlap with block tags... DRY?\n    if ( ( m = testOpenTag( src ) ) ) {\n      src.advance( m[0] );\n      const tag = m[1];\n      const single = m[3] || m[1] in singletons;\n      let element = [ tag ];\n      if ( m[2] ) {\n        element.push( parseHtmlAttr( m[2] ) );\n      }\n      if ( single ) { // single tag\n        list.add( element ).add( src.skipWS() );\n        continue;\n      }\n      else { // need terminator\n        // gulp up the rest of this block...\n        const reEndTag = re.compile( `^(.*?)(</${ tag }\\\\s*>)`, 's' );\n        if ( ( m = reEndTag.exec( src ) ) ) {\n          src.advance( m[0] );\n          if ( tag === 'code' ) {\n            element.push( m[1] );\n          }\n          else if ( tag === 'notextile' ) {\n            // HTML is still parsed, even though textile is not\n            list.merge( parseHtml( tokenize( m[1] ) ) );\n            continue;\n          }\n          else {\n            element = element.concat( parsePhrase( m[1], options ) );\n          }\n          list.add( element );\n          continue;\n        }\n        // end tag is missing, treat tag as normal text...\n      }\n      src.load();\n    }\n\n    // footnote\n    if ( ( m = reFootnote.exec( src ) ) && /\\S/.test( behind ) ) {\n      src.advance( m[0] );\n      list.add( [ 'sup', { 'class': 'footnote', 'id': 'fnr' + m[1] },\n                  ( m[2] === '!' ? m[1] // \"!\" suppresses the link\n                                 : [ 'a', { href: '#fn' + m[1] }, m[1] ] )\n                ] );\n      continue;\n    }\n\n    // caps / abbr\n    if ( ( m = reCaps.exec( src ) ) ) {\n      src.advance( m[0] );\n      let caps = [ 'span', { 'class': 'caps' }, m[1] ];\n      if ( m[2] ) {\n        // FIXME: use <abbr>, not acronym!\n        caps = [ 'acronym', { 'title': m[2] }, caps ];\n      }\n      list.add( caps );\n      continue;\n    }\n\n    // links\n    if ( ( boundary && ( m = reLink.exec( src ) ) ) ||\n                       ( m = reLinkFenced.exec( src ) ) ) {\n      src.advance( m[0] );\n      let title = m[1].match( reLinkTitle );\n      let inner = ( title ) ? m[1].slice( 0, m[1].length - title[0].length ) : m[1];\n      if ( ( pba = parseAttr( inner, 'a' ) ) ) {\n        inner = inner.slice( pba[0] );\n        pba = pba[1];\n      }\n      else {\n        pba = {};\n      }\n      if ( title && !inner ) {\n        inner = title[0];\n        title = '';\n      }\n      pba.href = m[2];\n      if ( title ) { pba.title = title[1]; }\n      list.add( [ 'a', pba ].concat( parsePhrase( inner.replace( /^(\\.?\\s*)/, '' ), options ) ) );\n      continue;\n    }\n\n    // no match, move by all \"uninteresting\" chars\n    m = /([a-zA-Z0-9,.':]+|[ \\f\\r\\t\\v\\xA0\\u2028\\u2029]+|[^\\0])/.exec( src );\n    if ( m ) {\n      list.add( m[0] );\n    }\n    src.advance( m ? m[0].length || 1 : 1 );\n  }\n  while ( src.valueOf() );\n\n  return list.get().map( parseGlyph );\n}\n\nexports.parsePhrase = parsePhrase;\n\n\n\n// WEBPACK FOOTER //\n// ./src/textile/phrase.js","const reClassid = /^\\(([^\\(\\)\\n]+)\\)/;\nconst rePaddingL = /^(\\(+)/;\nconst rePaddingR = /^(\\)+)/;\nconst reAlignBlock = /^(<>|<|>|=)/;\nconst reAlignImg = /^(<|>|=)/;\nconst reVAlign = /^(~|\\^|\\-)/;\nconst reColSpan = /^\\\\(\\d+)/;\nconst reRowSpan = /^\\/(\\d+)/;\nconst reStyles = /^\\{([^\\}]*)\\}/;\nconst reCSS = /^\\s*([^:\\s]+)\\s*:\\s*(.+)\\s*$/;\nconst reLang = /^\\[([^\\[\\]\\n]+)\\]/;\n\nconst pbaAlignLookup = {\n  '<': 'left',\n  '=': 'center',\n  '>': 'right',\n  '<>': 'justify'\n};\n\nconst pbaVAlignLookup = {\n  '~': 'bottom',\n  '^': 'top',\n  '-': 'middle'\n};\n\nfunction copyAttr ( s, blacklist ) {\n  if ( !s ) { return undefined; }\n  const d = {};\n  for ( const k in s ) {\n    if ( k in s && ( !blacklist || !( k in blacklist ) ) ) {\n      d[ k ] = s[ k ];\n    }\n  }\n  return d;\n}\n\nfunction testBlock ( name ) {\n  // \"in\" test would be better but what about fn#.?\n  return /^(?:table|t[dh]|t(?:foot|head|body)|b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)$/.test( name );\n}\n\n/*\n  The attr bit causes massive problems for span elements when parentheses are used.\n  Parentheses are a total mess and, unsurprisingly, cause trip-ups:\n\n   RC: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\" class=\"span\">(span) span (span)</em>`\n   PHP: `_{display:block}(span) span (span)_` -> `<em style=\"display:block;\">(span) span (span)</em>`\n\n  PHP and RC seem to mostly solve this by not parsing a final attr parens on spans if the\n  following character is a non-space. I've duplicated that: Class/ID is not matched on spans\n  if it is followed by `endToken` or <space>.\n\n  Lang is not matched here if it is followed by the end token. Theoretically I could limit the lang\n  attribute to /^\\[[a-z]{2+}(\\-[a-zA-Z0-9]+)*\\]/ because Textile is layered on top of HTML which\n  only accepts valid BCP 47 language tags, but who knows what atrocities are being preformed\n  out there in the real world. So this attempts to emulate the other libraries.\n*/\nfunction parseAttr ( input, element, endToken ) {\n  input = String( input );\n  if ( !input || element === 'notextile' ) {\n    return undefined;\n  }\n\n  let m;\n  const st = {};\n  const o = { 'style': st };\n  let remaining = input;\n\n  const isBlock = testBlock( element );\n  const isImg = element === 'img';\n  const isList = element === 'li';\n  const isPhrase = !isBlock && !isImg && element !== 'a';\n  const reAlign = ( isImg ) ? reAlignImg : reAlignBlock;\n\n  do {\n    if ( ( m = reStyles.exec( remaining ) ) ) {\n      m[1].split( ';' ).forEach( function ( p ) {\n        const d = p.match( reCSS );\n        if ( d ) { st[ d[1] ] = d[2]; }\n      });\n      remaining = remaining.slice( m[0].length );\n      continue;\n    }\n\n    if ( ( m = reLang.exec( remaining ) ) ) {\n      const rm = remaining.slice( m[0].length );\n      if ( ( !rm && isPhrase ) ||\n           ( endToken && endToken === rm.slice( 0, endToken.length ) ) ) {\n        m = null;\n      }\n      else {\n        o['lang'] = m[1];\n        remaining = remaining.slice( m[0].length );\n      }\n      continue;\n    }\n\n    if ( ( m = reClassid.exec( remaining ) ) ) {\n      const rm = remaining.slice( m[0].length );\n      if (\n          ( !rm && isPhrase ) ||\n          ( endToken && ( rm[0] === ' ' || endToken === rm.slice( 0, endToken.length ) ) )\n         ) {\n        m = null;\n      }\n      else {\n        const bits = m[1].split( '#' );\n        if ( bits[0] ) { o.class = bits[0]; }\n        if ( bits[1] ) { o.id = bits[1]; }\n        remaining = rm;\n      }\n      continue;\n    }\n\n    if ( isBlock || isList ) {\n      if ( ( m = rePaddingL.exec( remaining ) ) ) {\n        st[ 'padding-left' ] = `${ m[1].length }em`;\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n      if ( ( m = rePaddingR.exec( remaining ) ) ) {\n        st[ 'padding-right' ] = `${ m[1].length }em`;\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n    }\n\n    // only for blocks:\n    if ( isImg || isBlock || isList ) {\n      if ( ( m = reAlign.exec( remaining ) ) ) {\n        const align = pbaAlignLookup[ m[1] ];\n        if ( isImg ) {\n          o[ 'align' ] = align;\n        }\n        else {\n          st[ 'text-align' ] = align;\n        }\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n    }\n\n    // only for table cells\n    if ( element === 'td' || element === 'tr' ) {\n      if ( ( m = reVAlign.exec( remaining ) ) ) {\n        st[ 'vertical-align' ] = pbaVAlignLookup[ m[1] ];\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n    }\n    if ( element === 'td' ) {\n      if ( ( m = reColSpan.exec( remaining ) ) ) {\n        o[ 'colspan' ] = m[1];\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n      if ( ( m = reRowSpan.exec( remaining ) ) ) {\n        o[ 'rowspan' ] = m[1];\n        remaining = remaining.slice( m[0].length );\n        continue;\n      }\n    }\n  }\n  while ( m );\n\n  // collapse styles\n  const s = [];\n  for ( const v in st ) {\n    s.push( `${ v }:${ st[v] }` );\n  }\n  if ( s.length ) {\n    o.style = s.join( ';' );\n  }\n  else {\n    delete o.style;\n  }\n\n  return ( remaining === input ) ? undefined : [ input.length - remaining.length, o ];\n}\n\nfunction addLineNumber ( jsonmlEntryAttr, options, charPosToLine, charOffset, charPos ) {\n  if ( options.showOriginalLineNumber && charPosToLine ) {\n    charOffset = charOffset || 0;\n    if ( !jsonmlEntryAttr ) {\n      jsonmlEntryAttr = {};\n    }\n    jsonmlEntryAttr['data-line'] = charPosToLine[ charOffset + charPos ];\n    if ( options.cssClassOriginalLineNumber ) {\n      jsonmlEntryAttr['class'] = ( jsonmlEntryAttr['class'] ? jsonmlEntryAttr['class'] + ' ' : '' ) + options.cssClassOriginalLineNumber;\n    }\n  }\n  return jsonmlEntryAttr;\n}\n\nmodule.exports = {\n  copyAttr: copyAttr,\n  parseAttr: parseAttr,\n  addLineNumber: addLineNumber\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/textile/attr.js","/* textile glyph parser */\n\nconst re = require( '../re' );\n\nconst reApostrophe = /(\\w)'(\\w)/g;\nconst reArrow = /([^\\-]|^)->/;\nconst reClosingDQuote = re.compile( /([^\\s\\[\\(])\"(?=$|\\s|[:punct:])/g );\nconst reClosingSQuote = re.compile( /([^\\s\\[\\(])'(?=$|\\s|[:punct:])/g );\nconst reCopyright = /(\\b ?|\\s|^)(?:\\(C\\)|\\[C\\])/gi;\nconst reDimsign = /([\\d\\.,]+['\"]? ?)x( ?)(?=[\\d\\.,]['\"]?)/g;\nconst reDoublePrime = re.compile( /(\\d*[\\.,]?\\d+)\"(?=\\s|$|[:punct:])/g );\nconst reEllipsis = /([^.]?)\\.{3}/g;\nconst reEmdash = /(^|[\\s\\w])--([\\s\\w]|$)/g;\nconst reEndash = / - /g;\nconst reOpenDQuote = /\"/g;\nconst reOpenSQuote = /'/g;\nconst reRegistered = /(\\b ?|\\s|^)(?:\\(R\\)|\\[R\\])/gi;\nconst reSinglePrime = re.compile( /(\\d*[\\.,]?\\d+)'(?=\\s|$|[:punct:])/g );\nconst reTrademark = /(\\b ?|\\s|^)(?:\\((?:TM|tm)\\)|\\[(?:TM|tm)\\])/g;\n\nexports.parseGlyph = function parseGlyph ( src ) {\n  if ( typeof src !== 'string' ) {\n    return src;\n  }\n  // NB: order is important here ...\n  return src\n    .replace( reArrow, '$1&#8594;' )\n    .replace( reDimsign, '$1&#215;$2' )\n    .replace( reEllipsis, '$1&#8230;' )\n    .replace( reEmdash, '$1&#8212;$2' )\n    .replace( reEndash, ' &#8211; ' )\n    .replace( reTrademark, '$1&#8482;' )\n    .replace( reRegistered, '$1&#174;' )\n    .replace( reCopyright, '$1&#169;' )\n    // double quotes\n    .replace( reDoublePrime, '$1&#8243;' )\n    .replace( reClosingDQuote, '$1&#8221;' )\n    .replace( reOpenDQuote, '&#8220;' )\n    // single quotes\n    .replace( reSinglePrime, '$1&#8242;' )\n    .replace( reApostrophe, '$1&#8217;$2' )\n    .replace( reClosingSQuote, '$1&#8217;' )\n    .replace( reOpenSQuote, '&#8216;' )\n    // fractions and degrees\n    .replace( /[\\(\\[]1\\/4[\\]\\)]/, '&#188;' )\n    .replace( /[\\(\\[]1\\/2[\\]\\)]/, '&#189;' )\n    .replace( /[\\(\\[]3\\/4[\\]\\)]/, '&#190;' )\n    .replace( /[\\(\\[]o[\\]\\)]/, '&#176;' )\n    .replace( /[\\(\\[]\\+\\/\\-[\\]\\)]/, '&#177;' );\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/textile/glyph.js","/* eslint camelcase: 0 */\n\nexports.txblocks = '(?:b[qc]|div|notextile|pre|h[1-6]|fn\\\\d+|p|###)';\n\nexports.ucaps = 'A-Z' +\n    // Latin extended À-Þ\n    '\\u00c0-\\u00d6\\u00d8-\\u00de' +\n    // Latin caps with embelishments and ligatures...\n    '\\u0100\\u0102\\u0104\\u0106\\u0108\\u010a\\u010c\\u010e\\u0110\\u0112\\u0114\\u0116\\u0118\\u011a\\u011c\\u011e\\u0120\\u0122\\u0124\\u0126\\u0128\\u012a\\u012c\\u012e\\u0130\\u0132\\u0134\\u0136\\u0139\\u013b\\u013d\\u013f' +\n    '\\u0141\\u0143\\u0145\\u0147\\u014a\\u014c\\u014e\\u0150\\u0152\\u0154\\u0156\\u0158\\u015a\\u015c\\u015e\\u0160\\u0162\\u0164\\u0166\\u0168\\u016a\\u016c\\u016e\\u0170\\u0172\\u0174\\u0176\\u0178\\u0179\\u017b\\u017d' +\n    '\\u0181\\u0182\\u0184\\u0186\\u0187\\u0189-\\u018b\\u018e-\\u0191\\u0193\\u0194\\u0196-\\u0198\\u019c\\u019d\\u019f\\u01a0\\u01a2\\u01a4\\u01a6\\u01a7\\u01a9\\u01ac\\u01ae\\u01af\\u01b1-\\u01b3\\u01b5\\u01b7\\u01b8\\u01bc' +\n    '\\u01c4\\u01c7\\u01ca\\u01cd\\u01cf\\u01d1\\u01d3\\u01d5\\u01d7\\u01d9\\u01db\\u01de\\u01e0\\u01e2\\u01e4\\u01e6\\u01e8\\u01ea\\u01ec\\u01ee\\u01f1\\u01f4\\u01f6-\\u01f8\\u01fa\\u01fc\\u01fe' +\n    '\\u0200\\u0202\\u0204\\u0206\\u0208\\u020a\\u020c\\u020e\\u0210\\u0212\\u0214\\u0216\\u0218\\u021a\\u021c\\u021e\\u0220\\u0222\\u0224\\u0226\\u0228\\u022a\\u022c\\u022e\\u0230\\u0232\\u023a\\u023b\\u023d\\u023e' +\n    '\\u0241\\u0243-\\u0246\\u0248\\u024a\\u024c\\u024e' +\n    '\\u1e00\\u1e02\\u1e04\\u1e06\\u1e08\\u1e0a\\u1e0c\\u1e0e\\u1e10\\u1e12\\u1e14\\u1e16\\u1e18\\u1e1a\\u1e1c\\u1e1e\\u1e20\\u1e22\\u1e24\\u1e26\\u1e28\\u1e2a\\u1e2c\\u1e2e\\u1e30\\u1e32\\u1e34\\u1e36\\u1e38\\u1e3a\\u1e3c\\u1e3e\\u1e40' +\n    '\\u1e42\\u1e44\\u1e46\\u1e48\\u1e4a\\u1e4c\\u1e4e\\u1e50\\u1e52\\u1e54\\u1e56\\u1e58\\u1e5a\\u1e5c\\u1e5e\\u1e60\\u1e62\\u1e64\\u1e66\\u1e68\\u1e6a\\u1e6c\\u1e6e\\u1e70\\u1e72\\u1e74\\u1e76\\u1e78\\u1e7a\\u1e7c\\u1e7e' +\n    '\\u1e80\\u1e82\\u1e84\\u1e86\\u1e88\\u1e8a\\u1e8c\\u1e8e\\u1e90\\u1e92\\u1e94\\u1e9e\\u1ea0\\u1ea2\\u1ea4\\u1ea6\\u1ea8\\u1eaa\\u1eac\\u1eae\\u1eb0\\u1eb2\\u1eb4\\u1eb6\\u1eb8\\u1eba\\u1ebc\\u1ebe' +\n    '\\u1ec0\\u1ec2\\u1ec4\\u1ec6\\u1ec8\\u1eca\\u1ecc\\u1ece\\u1ed0\\u1ed2\\u1ed4\\u1ed6\\u1ed8\\u1eda\\u1edc\\u1ede\\u1ee0\\u1ee2\\u1ee4\\u1ee6\\u1ee8\\u1eea\\u1eec\\u1eee\\u1ef0\\u1ef2\\u1ef4\\u1ef6\\u1ef8\\u1efa\\u1efc\\u1efe' +\n    '\\u2c60\\u2c62-\\u2c64\\u2c67\\u2c69\\u2c6b\\u2c6d-\\u2c70\\u2c72\\u2c75\\u2c7e\\u2c7f' +\n    '\\ua722\\ua724\\ua726\\ua728\\ua72a\\ua72c\\ua72e\\ua732\\ua734\\ua736\\ua738\\ua73a\\ua73c\\ua73e' +\n    '\\ua740\\ua742\\ua744\\ua746\\ua748\\ua74a\\ua74c\\ua74e\\ua750\\ua752\\ua754\\ua756\\ua758\\ua75a\\ua75c\\ua75e\\ua760\\ua762\\ua764\\ua766\\ua768\\ua76a\\ua76c\\ua76e\\ua779\\ua77b\\ua77d\\ua77e' +\n    '\\ua780\\ua782\\ua784\\ua786\\ua78b\\ua78d\\ua790\\ua792\\ua7a0\\ua7a2\\ua7a4\\ua7a6\\ua7a8\\ua7aa';\n\nexports.txcite = ':((?:[^\\\\s()]|\\\\([^\\\\s()]+\\\\)|[()])+?)(?=[!-\\\\.:-@\\\\[\\\\\\\\\\\\]-`{-~]+(?:$|\\\\s)|$|\\\\s)';\n\nconst attr_class = exports.attr_class = '\\\\([^\\\\)]+\\\\)';\nconst attr_style = exports.attr_style = '\\\\{[^\\\\}]+\\\\}';\nconst attr_lang = exports.attr_lang = '\\\\[[^\\\\[\\\\]]+\\\\]';\nconst attr_align = exports.attr_align = '(?:<>|<|>|=)';\nconst attr_pad = exports.attr_pad = '[\\\\(\\\\)]+';\n\nconst txattr = exports.txattr = `(?:${ attr_class }|${ attr_style }|${ attr_lang }|${ attr_align }|${ attr_pad })*`;\n\nexports.txlisthd = `[\\\\t ]*[\\\\#\\\\*]*(\\\\*|\\\\#(?:_|\\\\d+)?)${ txattr }(?: +\\\\S|\\\\.\\\\s*(?=\\\\S|\\\\n))`;\n\n\n\n// WEBPACK FOOTER //\n// ./src/textile/re_ext.js","/* textile list parser */\nconst ribbon = require( '../ribbon' );\nconst re = require( '../re' );\nconst merge = require( '../merge' );\n\nconst { parseAttr, addLineNumber } = require( './attr' );\nconst { parsePhrase } = require( './phrase' );\n\nconst { txlisthd } = require( './re_ext' );\nre.pattern.txlisthd = txlisthd;\nconst reList = re.compile( /^((?:[:txlisthd:][^\\0]*?(?:\\r?\\n|$))+)(\\s*\\n|$)/, 's' );\nconst reItem = re.compile( /^([#\\*]+)([^\\0]+?)(\\n(?=[:txlisthd:])|$)/, 's' );\n\nfunction listPad ( n ) {\n  let s = '\\n';\n  while ( n-- ) {\n    s += '\\t';\n  }\n  return s;\n}\n\nfunction testList ( src ) {\n  return reList.exec( src );\n}\n\nfunction parseList ( src, options, charOffset, charPosToLine ) {\n  if ( options.showOriginalLineNumber ) {\n    const removedSrc = src.match( /(^|\\r?\\n)[\\t ]+/ );\n    if ( removedSrc && removedSrc[0] ) {\n      charOffset++;\n    }\n  }\n  src = ribbon( src.replace( /(^|\\r?\\n)[\\t ]+/, '$1' ) );\n\n  const stack = [];\n  const currIndex = {};\n  const lastIndex = options._lst || {};\n  let itemIndex = 0;\n  let listAttr;\n  let m;\n  let n;\n  let s;\n\n  while ( ( m = reItem.exec( src ) ) ) {\n    const item = [ 'li' ];\n    const destLevel = m[1].length;\n    const type = ( m[1].substr( -1 ) === '#' ) ? 'ol' : 'ul';\n    let newLi = null;\n    let lst;\n    let par;\n    let pba;\n    let r;\n\n    // list starts and continuations\n    if ( ( n = /^(_|\\d+)/.exec( m[2] ) ) ) {\n      itemIndex = isFinite( n[1] )\n            ? parseInt( n[1], 10 )\n            : lastIndex[ destLevel ] || currIndex[ destLevel ] || 1;\n      m[2] = m[2].slice( n[1].length );\n    }\n\n    if ( ( pba = parseAttr( m[2], 'li' ) ) ) {\n      m[2] = m[2].slice( pba[0] );\n      pba = pba[1];\n    }\n\n    pba = addLineNumber( pba, options, charPosToLine, charOffset, src.getPos() );\n\n    // list control\n    if ( /^\\.\\s*$/.test( m[2] ) ) {\n      listAttr = pba || {};\n      src.advance( m[0] );\n      continue;\n    }\n\n    // create nesting until we have correct level\n    while ( stack.length < destLevel ) {\n      // list always has an attribute object, this simplifies first-pba resolution\n      lst = [ type, {}, listPad( stack.length + 1 ), ( newLi = [ 'li' ] ) ];\n      par = stack[ stack.length - 1 ];\n      if ( par ) {\n        par.li.push( listPad( stack.length ) );\n        par.li.push( lst );\n      }\n      stack.push({\n        ul: lst,\n        li: newLi,\n        // count attributes's found per list\n        att: 0\n      });\n      currIndex[ stack.length ] = 1;\n    }\n\n    // remove nesting until we have correct level\n    while ( stack.length > destLevel ) {\n      r = stack.pop();\n      r.ul.push( listPad( stack.length ) );\n      // lists have a predictable structure - move pba from listitem to list\n      if ( r.att === 1 && !r.ul[3][1].substr ) {\n        merge( r.ul[1], r.ul[3].splice( 1, 1 )[ 0 ] );\n      }\n    }\n\n    // parent list\n    par = stack[ stack.length - 1 ];\n\n    if ( itemIndex ) {\n      par.ul[1].start = itemIndex;\n      currIndex[destLevel] = itemIndex;\n      // falsy prevents this from fireing until it is set again\n      itemIndex = 0;\n    }\n    if ( listAttr ) {\n      // \"more than 1\" prevent attribute transfers on list close\n      par.att = 9;\n      merge( par.ul[1], listAttr );\n      listAttr = null;\n    }\n\n    if ( !newLi ) {\n      par.ul.push( listPad( stack.length ), item );\n      par.li = item;\n    }\n    if ( pba ) {\n      par.li.push( pba );\n      par.att++;\n    }\n    Array.prototype.push.apply( par.li, parsePhrase( m[2].trim(), options ) );\n\n    src.advance( m[0] );\n    currIndex[destLevel] = ( currIndex[destLevel] || 0 ) + 1;\n  }\n\n  // remember indexes for continuations next time\n  options._lst = currIndex;\n\n  while ( stack.length ) {\n    s = stack.pop();\n    s.ul.push( listPad( stack.length ) );\n    // lists have a predictable structure - move pba from listitem to list\n    if ( s.att === 1 && !s.ul[3][1].substr ) {\n      merge( s.ul[1], s.ul[3].splice( 1, 1 )[0] );\n    }\n  }\n\n  return s.ul;\n}\n\nmodule.exports = {\n  testList: testList,\n  parseList: parseList\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/textile/list.js","/* definitions list parser */\n\nconst ribbon = require( '../ribbon' );\n\nconst { addLineNumber } = require( './attr' );\n\nconst reDeflist = /^((?:- (?:[^\\n]\\n?)+?)+:=(?: *\\n[^\\0]+?=:(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- )))))+/;\nconst reItem = /^((?:- (?:[^\\n]\\n?)+?)+):=( *\\n[^\\0]+?=:\\s*(?:\\n|$)|(?:[^\\0]+?(?:$|\\n(?=\\n|- ))))/;\n\nfunction testDefList ( src ) {\n  return reDeflist.exec( src );\n}\n\nfunction parseDefList ( src, options, charOffset, charPosToLine ) {\n  if ( options.showOriginalLineNumber ) {\n    const removedSrc = src.match( /^\\s+/ );\n    if ( removedSrc && removedSrc[0] ) {\n      charOffset += removedSrc[0].length;\n    }\n  }\n  src = ribbon( src.trim() );\n\n  // late loading to get around the lack of non-circular-dependency support in RequireJS\n  const parsePhrase = require( './phrase' ).parsePhrase;\n  const parseFlow = require( './flow' ).parseFlow;\n\n  const deflist = [ 'dl', '\\n' ];\n  let terms;\n  let def;\n  let m;\n\n  while ( ( m = reItem.exec( src ) ) ) {\n    // add terms\n    terms = m[1].split( /(?:^|\\n)\\- / );\n    let localCharOffset = terms[0].length;\n    terms = terms.slice( 1 );\n    let separators = [];\n    if ( options.showOriginalLineNumber ) {\n      separators = m[1].match( /(?:^|\\n)\\- /g ).slice( 1 );\n    }\n    while ( terms.length ) {\n      const term = terms.shift();\n      deflist.push( '\\t'\n                , [ 'dt' ].concat(\n                  addLineNumber({}, options, charPosToLine, charOffset, src.getPos() + localCharOffset )\n                  , parsePhrase( term.trim(), options ) )\n                , '\\n'\n                );\n      if ( options.showOriginalLineNumber ) {\n        localCharOffset += term.length;\n        // perhaps no separator at the end of the list\n        if ( separators.length ) {\n          localCharOffset += separators.shift().length;\n        }\n      }\n    }\n    // add definitions\n    def = m[2].trim();\n    if ( options.showOriginalLineNumber ) {\n      // rebase local char offset, and add +2 for ':=' between term and definition\n      localCharOffset = m[1].length + 2;\n\n      const removedSrc = m[2].match( /^\\s+/ );\n      if ( removedSrc && removedSrc[0] ) {\n        localCharOffset += removedSrc[0].length;\n      }\n    }\n    deflist.push( '\\t'\n              , [ 'dd' ].concat(\n                  addLineNumber({}, options, charPosToLine, charOffset, src.getPos() + localCharOffset )\n                  , ( /=:$/.test( def ) )\n                    ? parseFlow( def.slice( 0, -2 ).trim(), options, options.showOriginalLineNumber ? charPosToLine[ ( charOffset || 0 ) + localCharOffset + src.getPos() ] : 0 )\n                    : parsePhrase( def, options )\n                )\n              , '\\n'\n              );\n    src.advance( m[0] );\n  }\n  return deflist;\n}\n\nexports.testDefList = testDefList;\nexports.parseDefList = parseDefList;\n\n\n\n// WEBPACK FOOTER //\n// ./src/textile/deflist.js","/* textile table parser */\n\nconst re = require( '../re' );\nconst merge = require( '../merge' );\nconst ribbon = require( '../ribbon' );\n\nconst { parseAttr, addLineNumber } = require( './attr' );\nconst { parsePhrase } = require( './phrase' );\nconst { reIndent } = require( '../jsonml' );\n\nconst { txattr } = require( './re_ext' );\nre.pattern.txattr = txattr;\n\nconst reTable = re.compile( /^((?:table[:txattr:]\\.(?:\\s(.+?))\\s*\\n)?(?:(?:[:txattr:]\\.[^\\n\\S]*)?\\|.*?\\|[^\\n\\S]*(?:\\n|$))+)([^\\n\\S]*\\n)?/, 's' );\nconst reHead = /^table(_?)([^\\n]*?)\\.(?:[ \\t](.+?))?\\s*\\n/;\nconst reRow = re.compile( /^(?:\\|([~\\^\\-][:txattr:])\\.\\s*\\n)?([:txattr:]\\.[^\\n\\S]*)?\\|(.*?)\\|[^\\n\\S]*(\\n|$)/, 's' );\nconst reCaption = /^\\|=([^\\n+]*)\\n/;\nconst reColgroup = /^\\|:([^\\n+]*)\\|[\\r\\t ]*\\n/;\nconst reRowgroup = /^\\|([\\^\\-~])([^\\n+]*)\\.[ \\t\\r]*\\n/;\n\nconst charToTag = {\n  '^': 'thead',\n  '~': 'tfoot',\n  '-': 'tbody'\n};\n\nfunction parseColgroup ( src ) {\n  const colgroup = [ 'colgroup', {} ];\n  src.split( '|' )\n      .forEach( function ( s, isCol ) {\n        const col = ( isCol ) ? {} : colgroup[ 1 ];\n        let d = s.trim();\n        let m;\n        if ( d ) {\n          if ( ( m = /^\\\\(\\d+)/.exec( d ) ) ) {\n            col.span = +m[ 1 ];\n            d = d.slice( m[ 0 ].length );\n          }\n          if ( ( m = parseAttr( d, 'col' ) ) ) {\n            merge( col, m[ 1 ] );\n            d = d.slice( m[ 0 ] );\n          }\n          if ( ( m = /\\b\\d+\\b/.exec( d ) ) ) {\n            col.width = +m[0];\n          }\n        }\n        if ( isCol ) {\n          colgroup.push( '\\n\\t\\t', [ 'col', col ] );\n        }\n      });\n  return colgroup.concat( [ '\\n\\t' ] );\n}\n\nfunction testTable ( src ) {\n  return reTable.exec( src );\n}\n\nfunction parseTable ( src, options, charOffset, charPosToLine ) {\n  if ( options.showOriginalLineNumber ) {\n    const removedSrc = src.match( /^\\s+/ );\n    if ( removedSrc && removedSrc[0] ) {\n      charOffset += removedSrc[0].length;\n    }\n  }\n  src = ribbon( src.trim() );\n\n  const rowgroups = [];\n  let colgroup;\n  let caption;\n  const tAttr = {};\n  let tCurr;\n  let row;\n  let inner;\n  let pba;\n  let more;\n  let m;\n  let extended = 0;\n\n  const setRowGroup = function ( type, pba ) {\n    tCurr = [ type, pba || {} ];\n    rowgroups.push( tCurr );\n  };\n\n  if ( ( m = reHead.exec( src ) ) ) {\n    // parse and apply table attr\n    src.advance( m[0] );\n    pba = parseAttr( m[2], 'table' );\n    if ( pba ) {\n      merge( tAttr, pba[1] );\n    }\n    if ( m[3] ) {\n      tAttr.summary = m[3];\n    }\n  }\n\n  // caption\n  if ( ( m = reCaption.exec( src ) ) ) {\n    caption = [ 'caption' ];\n    if ( ( pba = parseAttr( m[1], 'caption' ) ) ) {\n      caption.push( pba[1] );\n      m[1] = m[1].slice( pba[0] );\n    }\n    if ( /\\./.test( m[1] ) ) { // mandatory \".\"\n      caption.push( m[1].slice( 1 ).replace( /\\|\\s*$/, '' ).trim() );\n      extended++;\n      src.advance( m[0] );\n    }\n    else {\n      caption = null;\n    }\n  }\n\n  do {\n    // colgroup\n    if ( ( m = reColgroup.exec( src ) ) ) {\n      colgroup = parseColgroup( m[1] );\n      extended++;\n    }\n    // \"rowgroup\" (tbody, thead, tfoot)\n    else if ( ( m = reRowgroup.exec( src ) ) ) {\n      // PHP allows any amount of these in any order\n      // and simply translates them straight through\n      // the same is done here.\n      const tag = charToTag[ m[1] ] || 'tbody';\n      pba = parseAttr( `${ m[2] } `, tag );\n      setRowGroup( tag, pba && pba[1] );\n      extended++;\n    }\n    // row\n    else if ( ( m = reRow.exec( src ) ) ) {\n      if ( !tCurr ) { setRowGroup( 'tbody' ); }\n\n      row = [ 'tr' ];\n\n      if ( m[2] && ( pba = parseAttr( m[2], 'tr' ) ) ) {\n        // FIXME: requires \"\\.\\s?\" -- else what ?\n        row.push( addLineNumber( pba[1], options, charPosToLine, charOffset, src.getPos() ) );\n      }\n      else {\n        row.push( addLineNumber({}, options, charPosToLine, charOffset, src.getPos() ) );\n      }\n\n      tCurr.push( '\\n\\t\\t', row );\n      inner = ribbon( m[3] );\n\n      do {\n        inner.save();\n\n        // cell loop\n        const th = inner.startsWith( '_' );\n        let cell = [ th ? 'th' : 'td' ];\n        if ( th ) {\n          inner.advance( 1 );\n        }\n\n        pba = parseAttr( inner, 'td' );\n        if ( pba ) {\n          inner.advance( pba[0] );\n          cell.push( pba[1] ); // FIXME: don't do this if next text fails\n        }\n\n        if ( pba || th ) {\n          const p = /^\\.\\s*/.exec( inner );\n          if ( p ) {\n            inner.advance( p[0] );\n          }\n          else {\n            cell = [ 'td' ];\n            inner.load();\n          }\n        }\n\n        const mx = /^(==.*?==|[^\\|])*/.exec( inner );\n        cell = cell.concat( parsePhrase( mx[0], options ) );\n        row.push( '\\n\\t\\t\\t', cell );\n        more = inner.valueOf().charAt( mx[0].length ) === '|';\n        inner.advance( mx[0].length + 1 );\n      }\n      while ( more );\n\n      row.push( '\\n\\t\\t' );\n    }\n    //\n    if ( m ) {\n      src.advance( m[0] );\n    }\n  }\n  while ( m );\n\n  // assemble table\n  let table = [ 'table', tAttr ];\n  if ( extended ) {\n    if ( caption ) {\n      table.push( '\\n\\t', caption );\n    }\n    if ( colgroup ) {\n      table.push( '\\n\\t', colgroup );\n    }\n    rowgroups.forEach( function ( tbody ) {\n      table.push( '\\n\\t', tbody.concat( [ '\\n\\t' ] ) );\n    });\n  }\n  else {\n    table = table.concat( reIndent( rowgroups[0].slice( 2 ), -1 ) );\n  }\n\n  table.push( '\\n' );\n  return table;\n}\n\nmodule.exports = {\n  parseColgroup: parseColgroup,\n  parseTable: parseTable,\n  testTable: testTable\n};\n\n\n\n// WEBPACK FOOTER //\n// ./src/textile/table.js"],"sourceRoot":""}